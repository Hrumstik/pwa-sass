"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/use-intl";
exports.ids = ["vendor-chunks/use-intl"];
exports.modules = {

/***/ "(ssr)/./node_modules/use-intl/dist/_IntlProvider.js":
/*!*****************************************************!*\
  !*** ./node_modules/use-intl/dist/_IntlProvider.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./development/_IntlProvider.js */ \"(ssr)/./node_modules/use-intl/dist/development/_IntlProvider.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9fSW50bFByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLDZJQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL3B3YS1zYWFzLy4vbm9kZV9tb2R1bGVzL3VzZS1pbnRsL2Rpc3QvX0ludGxQcm92aWRlci5qcz9hODZiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3Byb2R1Y3Rpb24vX0ludGxQcm92aWRlci5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RldmVsb3BtZW50L19JbnRsUHJvdmlkZXIuanMnKTtcbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/_IntlProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/_useLocale.js":
/*!**************************************************!*\
  !*** ./node_modules/use-intl/dist/_useLocale.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./development/_useLocale.js */ \"(ssr)/./node_modules/use-intl/dist/development/_useLocale.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9fdXNlTG9jYWxlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLHVJQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL3B3YS1zYWFzLy4vbm9kZV9tb2R1bGVzL3VzZS1pbnRsL2Rpc3QvX3VzZUxvY2FsZS5qcz8xNjFhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3Byb2R1Y3Rpb24vX3VzZUxvY2FsZS5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RldmVsb3BtZW50L191c2VMb2NhbGUuanMnKTtcbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/_useLocale.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/development/IntlContext-b5cc6be8.js":
/*!************************************************************************!*\
  !*** ./node_modules/use-intl/dist/development/IntlContext-b5cc6be8.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nconst IntlContext = /*#__PURE__*/ React.createContext(undefined);\nvar IntlContext$1 = IntlContext;\nexports.IntlContext = IntlContext$1;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9JbnRsQ29udGV4dC1iNWNjNmJlOC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDO0FBRXBCLE1BQU1DLGNBQWMsV0FBVyxHQUFFRixNQUFNRyxhQUFhLENBQUNDO0FBQ3JELElBQUlDLGdCQUFnQkg7QUFFcEJJLG1CQUFtQixHQUFHRCIsInNvdXJjZXMiOlsid2VicGFjazovL3B3YS1zYWFzLy4vbm9kZV9tb2R1bGVzL3VzZS1pbnRsL2Rpc3QvZGV2ZWxvcG1lbnQvSW50bENvbnRleHQtYjVjYzZiZTguanM/NDcwZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbmNvbnN0IEludGxDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcbnZhciBJbnRsQ29udGV4dCQxID0gSW50bENvbnRleHQ7XG5cbmV4cG9ydHMuSW50bENvbnRleHQgPSBJbnRsQ29udGV4dCQxO1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwicmVxdWlyZSIsIkludGxDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsInVuZGVmaW5lZCIsIkludGxDb250ZXh0JDEiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/development/IntlContext-b5cc6be8.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/development/_IntlProvider.js":
/*!*****************************************************************!*\
  !*** ./node_modules/use-intl/dist/development/_IntlProvider.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar initializeConfig = __webpack_require__(/*! ./initializeConfig-c503e215.js */ \"(ssr)/./node_modules/use-intl/dist/development/initializeConfig-c503e215.js\");\nvar IntlContext = __webpack_require__(/*! ./IntlContext-b5cc6be8.js */ \"(ssr)/./node_modules/use-intl/dist/development/IntlContext-b5cc6be8.js\");\nfunction _interopDefault(e) {\n    return e && e.__esModule ? e : {\n        default: e\n    };\n}\nvar React__default = /*#__PURE__*/ _interopDefault(React);\nfunction IntlProvider(_ref) {\n    let { children, defaultTranslationValues, formats, getMessageFallback, locale, messages, now, onError, timeZone } = _ref;\n    const [messageFormatCache] = React.useState(()=>new Map());\n    // Memoizing this value helps to avoid triggering a re-render of all\n    // context consumers in case the configuration didn't change. However,\n    // if some of the non-primitive values change, a re-render will still\n    // be triggered. Note that there's no need to put `memo` on `IntlProvider`\n    // itself, because the `children` typically change on every render.\n    // There's some burden on the consumer side if it's important to reduce\n    // re-renders, put that's how React works.\n    // See: https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/#context-updates-and-render-optimizations\n    const value = React.useMemo(()=>({\n            ...initializeConfig.initializeConfig({\n                locale,\n                defaultTranslationValues,\n                formats,\n                getMessageFallback,\n                messages,\n                now,\n                onError,\n                timeZone\n            }),\n            messageFormatCache\n        }), [\n        defaultTranslationValues,\n        formats,\n        getMessageFallback,\n        locale,\n        messageFormatCache,\n        messages,\n        now,\n        onError,\n        timeZone\n    ]);\n    return /*#__PURE__*/ React__default.default.createElement(IntlContext.IntlContext.Provider, {\n        value: value\n    }, children);\n}\nexports.IntlProvider = IntlProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9fSW50bFByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBRTdELElBQUlDLFFBQVFDLG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlDLG1CQUFtQkQsbUJBQU9BLENBQUM7QUFDL0IsSUFBSUUsY0FBY0YsbUJBQU9BLENBQUM7QUFFMUIsU0FBU0csZ0JBQWlCQyxDQUFDO0lBQUksT0FBT0EsS0FBS0EsRUFBRUMsVUFBVSxHQUFHRCxJQUFJO1FBQUVFLFNBQVNGO0lBQUU7QUFBRztBQUU5RSxJQUFJRyxpQkFBaUIsV0FBVyxHQUFFSixnQkFBZ0JKO0FBRWxELFNBQVNTLGFBQWFDLElBQUk7SUFDeEIsSUFBSSxFQUNGQyxRQUFRLEVBQ1JDLHdCQUF3QixFQUN4QkMsT0FBTyxFQUNQQyxrQkFBa0IsRUFDbEJDLE1BQU0sRUFDTkMsUUFBUSxFQUNSQyxHQUFHLEVBQ0hDLE9BQU8sRUFDUEMsUUFBUSxFQUNULEdBQUdUO0lBQ0osTUFBTSxDQUFDVSxtQkFBbUIsR0FBR3BCLE1BQU1xQixRQUFRLENBQUMsSUFBTSxJQUFJQztJQUV0RCxvRUFBb0U7SUFDcEUsc0VBQXNFO0lBQ3RFLHFFQUFxRTtJQUNyRSwwRUFBMEU7SUFDMUUsbUVBQW1FO0lBQ25FLHVFQUF1RTtJQUN2RSwwQ0FBMEM7SUFDMUMsK0pBQStKO0lBQy9KLE1BQU12QixRQUFRQyxNQUFNdUIsT0FBTyxDQUFDLElBQU87WUFDakMsR0FBR3JCLGlCQUFpQkEsZ0JBQWdCLENBQUM7Z0JBQ25DYTtnQkFDQUg7Z0JBQ0FDO2dCQUNBQztnQkFDQUU7Z0JBQ0FDO2dCQUNBQztnQkFDQUM7WUFDRixFQUFFO1lBQ0ZDO1FBQ0YsSUFBSTtRQUFDUjtRQUEwQkM7UUFBU0M7UUFBb0JDO1FBQVFLO1FBQW9CSjtRQUFVQztRQUFLQztRQUFTQztLQUFTO0lBQ3pILE9BQU8sV0FBVyxHQUFFWCxlQUFlRCxPQUFPLENBQUNpQixhQUFhLENBQUNyQixZQUFZQSxXQUFXLENBQUNzQixRQUFRLEVBQUU7UUFDekYxQixPQUFPQTtJQUNULEdBQUdZO0FBQ0w7QUFFQWIsb0JBQW9CLEdBQUdXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHdhLXNhYXMvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9fSW50bFByb3ZpZGVyLmpzP2EzMmYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGluaXRpYWxpemVDb25maWcgPSByZXF1aXJlKCcuL2luaXRpYWxpemVDb25maWctYzUwM2UyMTUuanMnKTtcbnZhciBJbnRsQ29udGV4dCA9IHJlcXVpcmUoJy4vSW50bENvbnRleHQtYjVjYzZiZTguanMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChlKSB7IHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7IGRlZmF1bHQ6IGUgfTsgfVxuXG52YXIgUmVhY3RfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0KFJlYWN0KTtcblxuZnVuY3Rpb24gSW50bFByb3ZpZGVyKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBjaGlsZHJlbixcbiAgICBkZWZhdWx0VHJhbnNsYXRpb25WYWx1ZXMsXG4gICAgZm9ybWF0cyxcbiAgICBnZXRNZXNzYWdlRmFsbGJhY2ssXG4gICAgbG9jYWxlLFxuICAgIG1lc3NhZ2VzLFxuICAgIG5vdyxcbiAgICBvbkVycm9yLFxuICAgIHRpbWVab25lXG4gIH0gPSBfcmVmO1xuICBjb25zdCBbbWVzc2FnZUZvcm1hdENhY2hlXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IG5ldyBNYXAoKSk7XG5cbiAgLy8gTWVtb2l6aW5nIHRoaXMgdmFsdWUgaGVscHMgdG8gYXZvaWQgdHJpZ2dlcmluZyBhIHJlLXJlbmRlciBvZiBhbGxcbiAgLy8gY29udGV4dCBjb25zdW1lcnMgaW4gY2FzZSB0aGUgY29uZmlndXJhdGlvbiBkaWRuJ3QgY2hhbmdlLiBIb3dldmVyLFxuICAvLyBpZiBzb21lIG9mIHRoZSBub24tcHJpbWl0aXZlIHZhbHVlcyBjaGFuZ2UsIGEgcmUtcmVuZGVyIHdpbGwgc3RpbGxcbiAgLy8gYmUgdHJpZ2dlcmVkLiBOb3RlIHRoYXQgdGhlcmUncyBubyBuZWVkIHRvIHB1dCBgbWVtb2Agb24gYEludGxQcm92aWRlcmBcbiAgLy8gaXRzZWxmLCBiZWNhdXNlIHRoZSBgY2hpbGRyZW5gIHR5cGljYWxseSBjaGFuZ2Ugb24gZXZlcnkgcmVuZGVyLlxuICAvLyBUaGVyZSdzIHNvbWUgYnVyZGVuIG9uIHRoZSBjb25zdW1lciBzaWRlIGlmIGl0J3MgaW1wb3J0YW50IHRvIHJlZHVjZVxuICAvLyByZS1yZW5kZXJzLCBwdXQgdGhhdCdzIGhvdyBSZWFjdCB3b3Jrcy5cbiAgLy8gU2VlOiBodHRwczovL2Jsb2cuaXNxdWFyZWRzb2Z0d2FyZS5jb20vMjAyMC8wNS9ibG9nZ2VkLWFuc3dlcnMtYS1tb3N0bHktY29tcGxldGUtZ3VpZGUtdG8tcmVhY3QtcmVuZGVyaW5nLWJlaGF2aW9yLyNjb250ZXh0LXVwZGF0ZXMtYW5kLXJlbmRlci1vcHRpbWl6YXRpb25zXG4gIGNvbnN0IHZhbHVlID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIC4uLmluaXRpYWxpemVDb25maWcuaW5pdGlhbGl6ZUNvbmZpZyh7XG4gICAgICBsb2NhbGUsXG4gICAgICBkZWZhdWx0VHJhbnNsYXRpb25WYWx1ZXMsXG4gICAgICBmb3JtYXRzLFxuICAgICAgZ2V0TWVzc2FnZUZhbGxiYWNrLFxuICAgICAgbWVzc2FnZXMsXG4gICAgICBub3csXG4gICAgICBvbkVycm9yLFxuICAgICAgdGltZVpvbmVcbiAgICB9KSxcbiAgICBtZXNzYWdlRm9ybWF0Q2FjaGVcbiAgfSksIFtkZWZhdWx0VHJhbnNsYXRpb25WYWx1ZXMsIGZvcm1hdHMsIGdldE1lc3NhZ2VGYWxsYmFjaywgbG9jYWxlLCBtZXNzYWdlRm9ybWF0Q2FjaGUsIG1lc3NhZ2VzLCBub3csIG9uRXJyb3IsIHRpbWVab25lXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEludGxDb250ZXh0LkludGxDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHZhbHVlXG4gIH0sIGNoaWxkcmVuKTtcbn1cblxuZXhwb3J0cy5JbnRsUHJvdmlkZXIgPSBJbnRsUHJvdmlkZXI7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJSZWFjdCIsInJlcXVpcmUiLCJpbml0aWFsaXplQ29uZmlnIiwiSW50bENvbnRleHQiLCJfaW50ZXJvcERlZmF1bHQiLCJlIiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJSZWFjdF9fZGVmYXVsdCIsIkludGxQcm92aWRlciIsIl9yZWYiLCJjaGlsZHJlbiIsImRlZmF1bHRUcmFuc2xhdGlvblZhbHVlcyIsImZvcm1hdHMiLCJnZXRNZXNzYWdlRmFsbGJhY2siLCJsb2NhbGUiLCJtZXNzYWdlcyIsIm5vdyIsIm9uRXJyb3IiLCJ0aW1lWm9uZSIsIm1lc3NhZ2VGb3JtYXRDYWNoZSIsInVzZVN0YXRlIiwiTWFwIiwidXNlTWVtbyIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/development/_IntlProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/development/_useLocale-321e619f.js":
/*!***********************************************************************!*\
  !*** ./node_modules/use-intl/dist/development/_useLocale-321e619f.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar IntlContext = __webpack_require__(/*! ./IntlContext-b5cc6be8.js */ \"(ssr)/./node_modules/use-intl/dist/development/IntlContext-b5cc6be8.js\");\nfunction useIntlContext() {\n    const context = React.useContext(IntlContext.IntlContext);\n    if (!context) {\n        throw new Error(\"No intl context found. Have you configured the provider?\");\n    }\n    return context;\n}\nfunction useLocale() {\n    return useIntlContext().locale;\n}\nexports.useIntlContext = useIntlContext;\nexports.useLocale = useLocale;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9fdXNlTG9jYWxlLTMyMWU2MTlmLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUMsY0FBY0QsbUJBQU9BLENBQUM7QUFFMUIsU0FBU0U7SUFDUCxNQUFNQyxVQUFVSixNQUFNSyxVQUFVLENBQUNILFlBQVlBLFdBQVc7SUFDeEQsSUFBSSxDQUFDRSxTQUFTO1FBQ1osTUFBTSxJQUFJRSxNQUFNO0lBQ2xCO0lBQ0EsT0FBT0Y7QUFDVDtBQUVBLFNBQVNHO0lBQ1AsT0FBT0osaUJBQWlCSyxNQUFNO0FBQ2hDO0FBRUFDLHNCQUFzQixHQUFHTjtBQUN6Qk0saUJBQWlCLEdBQUdGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHdhLXNhYXMvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9fdXNlTG9jYWxlLTMyMWU2MTlmLmpzPzU2NDQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIEludGxDb250ZXh0ID0gcmVxdWlyZSgnLi9JbnRsQ29udGV4dC1iNWNjNmJlOC5qcycpO1xuXG5mdW5jdGlvbiB1c2VJbnRsQ29udGV4dCgpIHtcbiAgY29uc3QgY29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoSW50bENvbnRleHQuSW50bENvbnRleHQpO1xuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGludGwgY29udGV4dCBmb3VuZC4gSGF2ZSB5b3UgY29uZmlndXJlZCB0aGUgcHJvdmlkZXI/JyApO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiB1c2VMb2NhbGUoKSB7XG4gIHJldHVybiB1c2VJbnRsQ29udGV4dCgpLmxvY2FsZTtcbn1cblxuZXhwb3J0cy51c2VJbnRsQ29udGV4dCA9IHVzZUludGxDb250ZXh0O1xuZXhwb3J0cy51c2VMb2NhbGUgPSB1c2VMb2NhbGU7XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJyZXF1aXJlIiwiSW50bENvbnRleHQiLCJ1c2VJbnRsQ29udGV4dCIsImNvbnRleHQiLCJ1c2VDb250ZXh0IiwiRXJyb3IiLCJ1c2VMb2NhbGUiLCJsb2NhbGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/development/_useLocale-321e619f.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/development/_useLocale.js":
/*!**************************************************************!*\
  !*** ./node_modules/use-intl/dist/development/_useLocale.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _useLocale = __webpack_require__(/*! ./_useLocale-321e619f.js */ \"(ssr)/./node_modules/use-intl/dist/development/_useLocale-321e619f.js\");\n__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n__webpack_require__(/*! ./IntlContext-b5cc6be8.js */ \"(ssr)/./node_modules/use-intl/dist/development/IntlContext-b5cc6be8.js\");\nexports.useLocale = _useLocale.useLocale;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9fdXNlTG9jYWxlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBRTdELElBQUlDLGFBQWFDLG1CQUFPQSxDQUFDO0FBQ3pCQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUlSSCxpQkFBaUIsR0FBR0UsV0FBV0UsU0FBUyIsInNvdXJjZXMiOlsid2VicGFjazovL3B3YS1zYWFzLy4vbm9kZV9tb2R1bGVzL3VzZS1pbnRsL2Rpc3QvZGV2ZWxvcG1lbnQvX3VzZUxvY2FsZS5qcz81MGYyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIF91c2VMb2NhbGUgPSByZXF1aXJlKCcuL191c2VMb2NhbGUtMzIxZTYxOWYuanMnKTtcbnJlcXVpcmUoJ3JlYWN0Jyk7XG5yZXF1aXJlKCcuL0ludGxDb250ZXh0LWI1Y2M2YmU4LmpzJyk7XG5cblxuXG5leHBvcnRzLnVzZUxvY2FsZSA9IF91c2VMb2NhbGUudXNlTG9jYWxlO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiX3VzZUxvY2FsZSIsInJlcXVpcmUiLCJ1c2VMb2NhbGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/development/_useLocale.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/development/core.js":
/*!********************************************************!*\
  !*** ./node_modules/use-intl/dist/development/core.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar initializeConfig = __webpack_require__(/*! ./initializeConfig-c503e215.js */ \"(ssr)/./node_modules/use-intl/dist/development/initializeConfig-c503e215.js\");\nvar createFormatter = __webpack_require__(/*! ./createFormatter-4ce6f6c8.js */ \"(ssr)/./node_modules/use-intl/dist/development/createFormatter-4ce6f6c8.js\");\n__webpack_require__(/*! intl-messageformat */ \"(ssr)/./node_modules/intl-messageformat/lib/index.js\");\n__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nfunction createTranslatorImpl(_ref, namespacePrefix) {\n    let { getMessageFallback, messages, namespace, onError, ...rest } = _ref;\n    // The `namespacePrefix` is part of the type system.\n    // See the comment in the function invocation.\n    messages = messages[namespacePrefix];\n    namespace = createFormatter.resolveNamespace(namespace, namespacePrefix);\n    return createFormatter.createBaseTranslator({\n        ...rest,\n        onError,\n        getMessageFallback,\n        messages,\n        namespace\n    });\n}\n/**\n * Translates messages from the given namespace by using the ICU syntax.\n * See https://formatjs.io/docs/core-concepts/icu-syntax.\n *\n * If no namespace is provided, all available messages are returned.\n * The namespace can also indicate nesting by using a dot\n * (e.g. `namespace.Component`).\n */ function createTranslator(_ref) {\n    let { getMessageFallback = initializeConfig.defaultGetMessageFallback, messages, namespace, onError = initializeConfig.defaultOnError, ...rest } = _ref;\n    // We have to wrap the actual function so the type inference for the optional\n    // namespace works correctly. See https://stackoverflow.com/a/71529575/343045\n    // The prefix (\"!\") is arbitrary.\n    return createTranslatorImpl({\n        ...rest,\n        onError,\n        getMessageFallback,\n        // @ts-expect-error `messages` is allowed to be `undefined` here and will be handled internally\n        messages: {\n            \"!\": messages\n        },\n        namespace: namespace ? \"!.\".concat(namespace) : \"!\"\n    }, \"!\");\n}\nexports.IntlError = initializeConfig.IntlError;\nexports.IntlErrorCode = initializeConfig.IntlErrorCode;\nexports.initializeConfig = initializeConfig.initializeConfig;\nexports.createFormatter = createFormatter.createFormatter;\nexports.createTranslator = createTranslator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9jb3JlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBRTdELElBQUlDLG1CQUFtQkMsbUJBQU9BLENBQUM7QUFDL0IsSUFBSUMsa0JBQWtCRCxtQkFBT0EsQ0FBQztBQUM5QkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFFUixTQUFTRSxxQkFBcUJDLElBQUksRUFBRUMsZUFBZTtJQUNqRCxJQUFJLEVBQ0ZDLGtCQUFrQixFQUNsQkMsUUFBUSxFQUNSQyxTQUFTLEVBQ1RDLE9BQU8sRUFDUCxHQUFHQyxNQUNKLEdBQUdOO0lBQ0osb0RBQW9EO0lBQ3BELDhDQUE4QztJQUM5Q0csV0FBV0EsUUFBUSxDQUFDRixnQkFBZ0I7SUFDcENHLFlBQVlOLGdCQUFnQlMsZ0JBQWdCLENBQUNILFdBQVdIO0lBQ3hELE9BQU9ILGdCQUFnQlUsb0JBQW9CLENBQUM7UUFDMUMsR0FBR0YsSUFBSTtRQUNQRDtRQUNBSDtRQUNBQztRQUNBQztJQUNGO0FBQ0Y7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU0ssaUJBQWlCVCxJQUFJO0lBQzVCLElBQUksRUFDRkUscUJBQXFCTixpQkFBaUJjLHlCQUF5QixFQUMvRFAsUUFBUSxFQUNSQyxTQUFTLEVBQ1RDLFVBQVVULGlCQUFpQmUsY0FBYyxFQUN6QyxHQUFHTCxNQUNKLEdBQUdOO0lBQ0osNkVBQTZFO0lBQzdFLDZFQUE2RTtJQUM3RSxpQ0FBaUM7SUFDakMsT0FBT0QscUJBQXFCO1FBQzFCLEdBQUdPLElBQUk7UUFDUEQ7UUFDQUg7UUFDQSwrRkFBK0Y7UUFDL0ZDLFVBQVU7WUFDUixLQUFLQTtRQUNQO1FBQ0FDLFdBQVdBLFlBQVksS0FBS1EsTUFBTSxDQUFDUixhQUFhO0lBQ2xELEdBQUc7QUFDTDtBQUVBVixpQkFBaUIsR0FBR0UsaUJBQWlCaUIsU0FBUztBQUM5Q25CLHFCQUFxQixHQUFHRSxpQkFBaUJrQixhQUFhO0FBQ3REcEIsd0JBQXdCLEdBQUdFLGlCQUFpQkEsZ0JBQWdCO0FBQzVERix1QkFBdUIsR0FBR0ksZ0JBQWdCQSxlQUFlO0FBQ3pESix3QkFBd0IsR0FBR2UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wd2Etc2Fhcy8uL25vZGVfbW9kdWxlcy91c2UtaW50bC9kaXN0L2RldmVsb3BtZW50L2NvcmUuanM/ZGI4NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBpbml0aWFsaXplQ29uZmlnID0gcmVxdWlyZSgnLi9pbml0aWFsaXplQ29uZmlnLWM1MDNlMjE1LmpzJyk7XG52YXIgY3JlYXRlRm9ybWF0dGVyID0gcmVxdWlyZSgnLi9jcmVhdGVGb3JtYXR0ZXItNGNlNmY2YzguanMnKTtcbnJlcXVpcmUoJ2ludGwtbWVzc2FnZWZvcm1hdCcpO1xucmVxdWlyZSgncmVhY3QnKTtcblxuZnVuY3Rpb24gY3JlYXRlVHJhbnNsYXRvckltcGwoX3JlZiwgbmFtZXNwYWNlUHJlZml4KSB7XG4gIGxldCB7XG4gICAgZ2V0TWVzc2FnZUZhbGxiYWNrLFxuICAgIG1lc3NhZ2VzLFxuICAgIG5hbWVzcGFjZSxcbiAgICBvbkVycm9yLFxuICAgIC4uLnJlc3RcbiAgfSA9IF9yZWY7XG4gIC8vIFRoZSBgbmFtZXNwYWNlUHJlZml4YCBpcyBwYXJ0IG9mIHRoZSB0eXBlIHN5c3RlbS5cbiAgLy8gU2VlIHRoZSBjb21tZW50IGluIHRoZSBmdW5jdGlvbiBpbnZvY2F0aW9uLlxuICBtZXNzYWdlcyA9IG1lc3NhZ2VzW25hbWVzcGFjZVByZWZpeF07XG4gIG5hbWVzcGFjZSA9IGNyZWF0ZUZvcm1hdHRlci5yZXNvbHZlTmFtZXNwYWNlKG5hbWVzcGFjZSwgbmFtZXNwYWNlUHJlZml4KTtcbiAgcmV0dXJuIGNyZWF0ZUZvcm1hdHRlci5jcmVhdGVCYXNlVHJhbnNsYXRvcih7XG4gICAgLi4ucmVzdCxcbiAgICBvbkVycm9yLFxuICAgIGdldE1lc3NhZ2VGYWxsYmFjayxcbiAgICBtZXNzYWdlcyxcbiAgICBuYW1lc3BhY2VcbiAgfSk7XG59XG5cbi8qKlxuICogVHJhbnNsYXRlcyBtZXNzYWdlcyBmcm9tIHRoZSBnaXZlbiBuYW1lc3BhY2UgYnkgdXNpbmcgdGhlIElDVSBzeW50YXguXG4gKiBTZWUgaHR0cHM6Ly9mb3JtYXRqcy5pby9kb2NzL2NvcmUtY29uY2VwdHMvaWN1LXN5bnRheC5cbiAqXG4gKiBJZiBubyBuYW1lc3BhY2UgaXMgcHJvdmlkZWQsIGFsbCBhdmFpbGFibGUgbWVzc2FnZXMgYXJlIHJldHVybmVkLlxuICogVGhlIG5hbWVzcGFjZSBjYW4gYWxzbyBpbmRpY2F0ZSBuZXN0aW5nIGJ5IHVzaW5nIGEgZG90XG4gKiAoZS5nLiBgbmFtZXNwYWNlLkNvbXBvbmVudGApLlxuICovXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2xhdG9yKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBnZXRNZXNzYWdlRmFsbGJhY2sgPSBpbml0aWFsaXplQ29uZmlnLmRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2ssXG4gICAgbWVzc2FnZXMsXG4gICAgbmFtZXNwYWNlLFxuICAgIG9uRXJyb3IgPSBpbml0aWFsaXplQ29uZmlnLmRlZmF1bHRPbkVycm9yLFxuICAgIC4uLnJlc3RcbiAgfSA9IF9yZWY7XG4gIC8vIFdlIGhhdmUgdG8gd3JhcCB0aGUgYWN0dWFsIGZ1bmN0aW9uIHNvIHRoZSB0eXBlIGluZmVyZW5jZSBmb3IgdGhlIG9wdGlvbmFsXG4gIC8vIG5hbWVzcGFjZSB3b3JrcyBjb3JyZWN0bHkuIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNzE1Mjk1NzUvMzQzMDQ1XG4gIC8vIFRoZSBwcmVmaXggKFwiIVwiKSBpcyBhcmJpdHJhcnkuXG4gIHJldHVybiBjcmVhdGVUcmFuc2xhdG9ySW1wbCh7XG4gICAgLi4ucmVzdCxcbiAgICBvbkVycm9yLFxuICAgIGdldE1lc3NhZ2VGYWxsYmFjayxcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGBtZXNzYWdlc2AgaXMgYWxsb3dlZCB0byBiZSBgdW5kZWZpbmVkYCBoZXJlIGFuZCB3aWxsIGJlIGhhbmRsZWQgaW50ZXJuYWxseVxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAnISc6IG1lc3NhZ2VzXG4gICAgfSxcbiAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZSA/IFwiIS5cIi5jb25jYXQobmFtZXNwYWNlKSA6ICchJ1xuICB9LCAnIScpO1xufVxuXG5leHBvcnRzLkludGxFcnJvciA9IGluaXRpYWxpemVDb25maWcuSW50bEVycm9yO1xuZXhwb3J0cy5JbnRsRXJyb3JDb2RlID0gaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3JDb2RlO1xuZXhwb3J0cy5pbml0aWFsaXplQ29uZmlnID0gaW5pdGlhbGl6ZUNvbmZpZy5pbml0aWFsaXplQ29uZmlnO1xuZXhwb3J0cy5jcmVhdGVGb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIuY3JlYXRlRm9ybWF0dGVyO1xuZXhwb3J0cy5jcmVhdGVUcmFuc2xhdG9yID0gY3JlYXRlVHJhbnNsYXRvcjtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImluaXRpYWxpemVDb25maWciLCJyZXF1aXJlIiwiY3JlYXRlRm9ybWF0dGVyIiwiY3JlYXRlVHJhbnNsYXRvckltcGwiLCJfcmVmIiwibmFtZXNwYWNlUHJlZml4IiwiZ2V0TWVzc2FnZUZhbGxiYWNrIiwibWVzc2FnZXMiLCJuYW1lc3BhY2UiLCJvbkVycm9yIiwicmVzdCIsInJlc29sdmVOYW1lc3BhY2UiLCJjcmVhdGVCYXNlVHJhbnNsYXRvciIsImNyZWF0ZVRyYW5zbGF0b3IiLCJkZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrIiwiZGVmYXVsdE9uRXJyb3IiLCJjb25jYXQiLCJJbnRsRXJyb3IiLCJJbnRsRXJyb3JDb2RlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/development/core.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/development/createFormatter-4ce6f6c8.js":
/*!****************************************************************************!*\
  !*** ./node_modules/use-intl/dist/development/createFormatter-4ce6f6c8.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar IntlMessageFormat = __webpack_require__(/*! intl-messageformat */ \"(ssr)/./node_modules/intl-messageformat/lib/index.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar initializeConfig = __webpack_require__(/*! ./initializeConfig-c503e215.js */ \"(ssr)/./node_modules/use-intl/dist/development/initializeConfig-c503e215.js\");\nfunction _interopDefault(e) {\n    return e && e.__esModule ? e : {\n        default: e\n    };\n}\nvar IntlMessageFormat__default = /*#__PURE__*/ _interopDefault(IntlMessageFormat);\n// eslint-disable-next-line import/no-named-as-default -- False positive\nfunction setTimeZoneInFormats(formats, timeZone) {\n    if (!formats) return formats;\n    // The only way to set a time zone with `intl-messageformat` is to merge it into the formats\n    // https://github.com/formatjs/formatjs/blob/8256c5271505cf2606e48e3c97ecdd16ede4f1b5/packages/intl/src/message.ts#L15\n    return Object.keys(formats).reduce((acc, key)=>{\n        acc[key] = {\n            timeZone,\n            ...formats[key]\n        };\n        return acc;\n    }, {});\n}\n/**\n * `intl-messageformat` uses separate keys for `date` and `time`, but there's\n * only one native API: `Intl.DateTimeFormat`. Additionally you might want to\n * include both a time and a date in a value, therefore the separation doesn't\n * seem so useful. We offer a single `dateTime` namespace instead, but we have\n * to convert the format before `intl-messageformat` can be used.\n */ function convertFormatsToIntlMessageFormat(formats, timeZone) {\n    const formatsWithTimeZone = timeZone ? {\n        ...formats,\n        dateTime: setTimeZoneInFormats(formats.dateTime, timeZone)\n    } : formats;\n    const mfDateDefaults = IntlMessageFormat__default.default.formats.date;\n    const defaultDateFormats = timeZone ? setTimeZoneInFormats(mfDateDefaults, timeZone) : mfDateDefaults;\n    const mfTimeDefaults = IntlMessageFormat__default.default.formats.time;\n    const defaultTimeFormats = timeZone ? setTimeZoneInFormats(mfTimeDefaults, timeZone) : mfTimeDefaults;\n    return {\n        ...formatsWithTimeZone,\n        date: {\n            ...defaultDateFormats,\n            ...formatsWithTimeZone === null || formatsWithTimeZone === void 0 ? void 0 : formatsWithTimeZone.dateTime\n        },\n        time: {\n            ...defaultTimeFormats,\n            ...formatsWithTimeZone === null || formatsWithTimeZone === void 0 ? void 0 : formatsWithTimeZone.dateTime\n        }\n    };\n}\n// eslint-disable-next-line import/no-named-as-default -- False positive\nfunction resolvePath(locale, messages, key, namespace) {\n    const fullKey = initializeConfig.joinPath(namespace, key);\n    if (!messages) {\n        throw new Error(\"No messages available at `\".concat(namespace, \"`.\"));\n    }\n    let message = messages;\n    key.split(\".\").forEach((part)=>{\n        const next = message[part];\n        if (part == null || next == null) {\n            throw new Error(\"Could not resolve `\".concat(fullKey, \"` in messages for locale `\").concat(locale, \"`.\"));\n        }\n        message = next;\n    });\n    return message;\n}\nfunction prepareTranslationValues(values) {\n    if (Object.keys(values).length === 0) return undefined;\n    // Workaround for https://github.com/formatjs/formatjs/issues/1467\n    const transformedValues = {};\n    Object.keys(values).forEach((key)=>{\n        let index = 0;\n        const value = values[key];\n        let transformed;\n        if (typeof value === \"function\") {\n            transformed = (chunks)=>{\n                const result = value(chunks);\n                return /*#__PURE__*/ React.isValidElement(result) ? /*#__PURE__*/ React.cloneElement(result, {\n                    key: key + index++\n                }) : result;\n            };\n        } else {\n            transformed = value;\n        }\n        transformedValues[key] = transformed;\n    });\n    return transformedValues;\n}\nfunction getMessagesOrError(locale, messages, namespace) {\n    let onError = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : initializeConfig.defaultOnError;\n    try {\n        if (!messages) {\n            throw new Error(\"No messages were configured on the provider.\");\n        }\n        const retrievedMessages = namespace ? resolvePath(locale, messages, namespace) : messages;\n        if (!retrievedMessages) {\n            throw new Error(\"No messages for namespace `\".concat(namespace, \"` found.\"));\n        }\n        return retrievedMessages;\n    } catch (error) {\n        const intlError = new initializeConfig.IntlError(initializeConfig.IntlErrorCode.MISSING_MESSAGE, error.message);\n        onError(intlError);\n        return intlError;\n    }\n}\nfunction getPlainMessage(candidate, values) {\n    if (values) return undefined;\n    const unescapedMessage = candidate.replace(/'([{}])/gi, \"$1\");\n    // Placeholders can be in the message if there are default values,\n    // or if the user has forgotten to provide values. In the latter\n    // case we need to compile the message to receive an error.\n    const hasPlaceholders = /<|{/.test(unescapedMessage);\n    if (!hasPlaceholders) {\n        return unescapedMessage;\n    }\n    return undefined;\n}\nfunction createBaseTranslator(config) {\n    const messagesOrError = getMessagesOrError(config.locale, config.messages, config.namespace, config.onError);\n    return createBaseTranslatorImpl({\n        ...config,\n        messagesOrError\n    });\n}\nfunction createBaseTranslatorImpl(_ref) {\n    let { defaultTranslationValues, formats: globalFormats, getMessageFallback = initializeConfig.defaultGetMessageFallback, locale, messageFormatCache, messagesOrError, namespace, onError, timeZone } = _ref;\n    function getFallbackFromErrorAndNotify(key, code, message) {\n        const error = new initializeConfig.IntlError(code, message);\n        onError(error);\n        return getMessageFallback({\n            error,\n            key,\n            namespace\n        });\n    }\n    function translateBaseFn(/** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */ key, /** Key value pairs for values to interpolate into the message. */ values, /** Provide custom formats for numbers, dates and times. */ formats) {\n        if (messagesOrError instanceof initializeConfig.IntlError) {\n            // We have already warned about this during render\n            return getMessageFallback({\n                error: messagesOrError,\n                key,\n                namespace\n            });\n        }\n        const messages = messagesOrError;\n        let message;\n        try {\n            message = resolvePath(locale, messages, key, namespace);\n        } catch (error) {\n            return getFallbackFromErrorAndNotify(key, initializeConfig.IntlErrorCode.MISSING_MESSAGE, error.message);\n        }\n        const cacheKey = initializeConfig.joinPath(locale, namespace, key, String(message));\n        let messageFormat;\n        if (messageFormatCache !== null && messageFormatCache !== void 0 && messageFormatCache.has(cacheKey)) {\n            messageFormat = messageFormatCache.get(cacheKey);\n        } else {\n            if (typeof message === \"object\") {\n                let code, errorMessage;\n                if (Array.isArray(message)) {\n                    code = initializeConfig.IntlErrorCode.INVALID_MESSAGE;\n                    {\n                        errorMessage = \"Message at `\".concat(initializeConfig.joinPath(namespace, key), \"` resolved to an array, but only strings are supported. See https://next-intl-docs.vercel.app/docs/usage/messages#arrays-of-messages\");\n                    }\n                } else {\n                    code = initializeConfig.IntlErrorCode.INSUFFICIENT_PATH;\n                    {\n                        errorMessage = \"Message at `\".concat(initializeConfig.joinPath(namespace, key), \"` resolved to an object, but only strings are supported. Use a `.` to retrieve nested messages. See https://next-intl-docs.vercel.app/docs/usage/messages#structuring-messages\");\n                    }\n                }\n                return getFallbackFromErrorAndNotify(key, code, errorMessage);\n            }\n            // Hot path that avoids creating an `IntlMessageFormat` instance\n            const plainMessage = getPlainMessage(message, values);\n            if (plainMessage) return plainMessage;\n            try {\n                messageFormat = new IntlMessageFormat__default.default(message, locale, convertFormatsToIntlMessageFormat({\n                    ...globalFormats,\n                    ...formats\n                }, timeZone), {\n                    formatters: {\n                        getNumberFormat (locales, options) {\n                            return new Intl.NumberFormat(locales, options);\n                        },\n                        getDateTimeFormat (locales, options) {\n                            // Workaround for https://github.com/formatjs/formatjs/issues/4279\n                            return new Intl.DateTimeFormat(locales, {\n                                timeZone,\n                                ...options\n                            });\n                        },\n                        getPluralRules (locales, options) {\n                            return new Intl.PluralRules(locales, options);\n                        }\n                    }\n                });\n            } catch (error) {\n                const thrownError = error;\n                return getFallbackFromErrorAndNotify(key, initializeConfig.IntlErrorCode.INVALID_MESSAGE, thrownError.message + (\"originalMessage\" in thrownError ? \" (\".concat(thrownError.originalMessage, \")\") : \"\"));\n            }\n            messageFormatCache === null || messageFormatCache === void 0 || messageFormatCache.set(cacheKey, messageFormat);\n        }\n        try {\n            const formattedMessage = messageFormat.format(// @ts-expect-error `intl-messageformat` expects a different format\n            // for rich text elements since a recent minor update. This\n            // needs to be evaluated in detail, possibly also in regards\n            // to be able to format to parts.\n            prepareTranslationValues({\n                ...defaultTranslationValues,\n                ...values\n            }));\n            if (formattedMessage == null) {\n                throw new Error(\"Unable to format `\".concat(key, \"` in \").concat(namespace ? \"namespace `\".concat(namespace, \"`\") : \"messages\"));\n            }\n            // Limit the function signature to return strings or React elements\n            return /*#__PURE__*/ React.isValidElement(formattedMessage) || // Arrays of React elements\n            Array.isArray(formattedMessage) || typeof formattedMessage === \"string\" ? formattedMessage : String(formattedMessage);\n        } catch (error) {\n            return getFallbackFromErrorAndNotify(key, initializeConfig.IntlErrorCode.FORMATTING_ERROR, error.message);\n        }\n    }\n    function translateFn(/** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */ key, /** Key value pairs for values to interpolate into the message. */ values, /** Provide custom formats for numbers, dates and times. */ formats) {\n        const result = translateBaseFn(key, values, formats);\n        if (typeof result !== \"string\") {\n            return getFallbackFromErrorAndNotify(key, initializeConfig.IntlErrorCode.INVALID_MESSAGE, \"The message `\".concat(key, \"` in \").concat(namespace ? \"namespace `\".concat(namespace, \"`\") : \"messages\", \" didn't resolve to a string. If you want to format rich text, use `t.rich` instead.\"));\n        }\n        return result;\n    }\n    translateFn.rich = translateBaseFn;\n    // Augment `translateBaseFn` to return plain strings\n    translateFn.markup = (key, values, formats)=>{\n        const result = translateBaseFn(key, // @ts-expect-error -- `MarkupTranslationValues` is practically a sub type\n        // of `RichTranslationValues` but TypeScript isn't smart enough here.\n        values, formats);\n        // When only string chunks are provided to the parser, only\n        // strings should be returned here. Note that we need a runtime\n        // check for this since rich text values could be accidentally\n        // inherited from `defaultTranslationValues`.\n        if (typeof result !== \"string\") {\n            const error = new initializeConfig.IntlError(initializeConfig.IntlErrorCode.FORMATTING_ERROR, \"`t.markup` only accepts functions for formatting that receive and return strings.\\n\\nE.g. t.markup('markup', {b: (chunks) => `<b>${chunks}</b>`})\");\n            onError(error);\n            return getMessageFallback({\n                error,\n                key,\n                namespace\n            });\n        }\n        return result;\n    };\n    translateFn.raw = (key)=>{\n        if (messagesOrError instanceof initializeConfig.IntlError) {\n            // We have already warned about this during render\n            return getMessageFallback({\n                error: messagesOrError,\n                key,\n                namespace\n            });\n        }\n        const messages = messagesOrError;\n        try {\n            return resolvePath(locale, messages, key, namespace);\n        } catch (error) {\n            return getFallbackFromErrorAndNotify(key, initializeConfig.IntlErrorCode.MISSING_MESSAGE, error.message);\n        }\n    };\n    return translateFn;\n}\n/**\n * For the strictly typed messages to work we have to wrap the namespace into\n * a mandatory prefix. See https://stackoverflow.com/a/71529575/343045\n */ function resolveNamespace(namespace, namespacePrefix) {\n    return namespace === namespacePrefix ? undefined : namespace.slice((namespacePrefix + \".\").length);\n}\nconst SECOND = 1;\nconst MINUTE = SECOND * 60;\nconst HOUR = MINUTE * 60;\nconst DAY = HOUR * 24;\nconst WEEK = DAY * 7;\nconst MONTH = DAY * (365 / 12); // Approximation\nconst QUARTER = MONTH * 3;\nconst YEAR = DAY * 365;\nconst UNIT_SECONDS = {\n    second: SECOND,\n    seconds: SECOND,\n    minute: MINUTE,\n    minutes: MINUTE,\n    hour: HOUR,\n    hours: HOUR,\n    day: DAY,\n    days: DAY,\n    week: WEEK,\n    weeks: WEEK,\n    month: MONTH,\n    months: MONTH,\n    quarter: QUARTER,\n    quarters: QUARTER,\n    year: YEAR,\n    years: YEAR\n};\nfunction resolveRelativeTimeUnit(seconds) {\n    const absValue = Math.abs(seconds);\n    if (absValue < MINUTE) {\n        return \"second\";\n    } else if (absValue < HOUR) {\n        return \"minute\";\n    } else if (absValue < DAY) {\n        return \"hour\";\n    } else if (absValue < WEEK) {\n        return \"day\";\n    } else if (absValue < MONTH) {\n        return \"week\";\n    } else if (absValue < YEAR) {\n        return \"month\";\n    }\n    return \"year\";\n}\nfunction calculateRelativeTimeValue(seconds, unit) {\n    // We have to round the resulting values, as `Intl.RelativeTimeFormat`\n    // will include fractions like '2.1 hours ago'.\n    return Math.round(seconds / UNIT_SECONDS[unit]);\n}\nfunction createFormatter(_ref) {\n    let { formats, locale, now: globalNow, onError = initializeConfig.defaultOnError, timeZone: globalTimeZone } = _ref;\n    function resolveFormatOrOptions(typeFormats, formatOrOptions) {\n        let options;\n        if (typeof formatOrOptions === \"string\") {\n            const formatName = formatOrOptions;\n            options = typeFormats === null || typeFormats === void 0 ? void 0 : typeFormats[formatName];\n            if (!options) {\n                const error = new initializeConfig.IntlError(initializeConfig.IntlErrorCode.MISSING_FORMAT, \"Format `\".concat(formatName, \"` is not available. You can configure it on the provider or provide custom options.\"));\n                onError(error);\n                throw error;\n            }\n        } else {\n            options = formatOrOptions;\n        }\n        return options;\n    }\n    function getFormattedValue(formatOrOptions, typeFormats, formatter, getFallback) {\n        let options;\n        try {\n            options = resolveFormatOrOptions(typeFormats, formatOrOptions);\n        } catch (error) {\n            return getFallback();\n        }\n        try {\n            return formatter(options);\n        } catch (error) {\n            onError(new initializeConfig.IntlError(initializeConfig.IntlErrorCode.FORMATTING_ERROR, error.message));\n            return getFallback();\n        }\n    }\n    function dateTime(/** If a number is supplied, this is interpreted as a UTC timestamp. */ value, /** If a time zone is supplied, the `value` is converted to that time zone.\n   * Otherwise the user time zone will be used. */ formatOrOptions) {\n        return getFormattedValue(formatOrOptions, formats === null || formats === void 0 ? void 0 : formats.dateTime, (options)=>{\n            var _options;\n            if (!((_options = options) !== null && _options !== void 0 && _options.timeZone)) {\n                if (globalTimeZone) {\n                    options = {\n                        ...options,\n                        timeZone: globalTimeZone\n                    };\n                } else {\n                    onError(new initializeConfig.IntlError(initializeConfig.IntlErrorCode.ENVIRONMENT_FALLBACK, \"The `timeZone` parameter wasn't provided and there is no global default configured. Consider adding a global default to avoid markup mismatches caused by environment differences. Learn more: https://next-intl-docs.vercel.app/docs/configuration#time-zone\"));\n                }\n            }\n            return new Intl.DateTimeFormat(locale, options).format(value);\n        }, ()=>String(value));\n    }\n    function number(value, formatOrOptions) {\n        return getFormattedValue(formatOrOptions, formats === null || formats === void 0 ? void 0 : formats.number, (options)=>new Intl.NumberFormat(locale, options).format(value), ()=>String(value));\n    }\n    function getGlobalNow() {\n        if (globalNow) {\n            return globalNow;\n        } else {\n            onError(new initializeConfig.IntlError(initializeConfig.IntlErrorCode.ENVIRONMENT_FALLBACK, \"The `now` parameter wasn't provided and there is no global default configured. Consider adding a global default to avoid markup mismatches caused by environment differences. Learn more: https://next-intl-docs.vercel.app/docs/configuration#now\"));\n            return new Date();\n        }\n    }\n    function extractNowDate(nowOrOptions) {\n        if (nowOrOptions instanceof Date || typeof nowOrOptions === \"number\") {\n            return new Date(nowOrOptions);\n        }\n        if ((nowOrOptions === null || nowOrOptions === void 0 ? void 0 : nowOrOptions.now) !== undefined) {\n            return new Date(nowOrOptions.now);\n        }\n        return getGlobalNow();\n    }\n    function relativeTime(/** The date time that needs to be formatted. */ date, /** The reference point in time to which `date` will be formatted in relation to.  */ nowOrOptions) {\n        try {\n            const dateDate = new Date(date);\n            const nowDate = extractNowDate(nowOrOptions);\n            const seconds = (dateDate.getTime() - nowDate.getTime()) / 1000;\n            const unit = typeof nowOrOptions === \"number\" || nowOrOptions instanceof Date || (nowOrOptions === null || nowOrOptions === void 0 ? void 0 : nowOrOptions.unit) === undefined ? resolveRelativeTimeUnit(seconds) : nowOrOptions.unit;\n            const value = calculateRelativeTimeValue(seconds, unit);\n            return new Intl.RelativeTimeFormat(locale, {\n                // `numeric: 'auto'` can theoretically produce output like \"yesterday\",\n                // but it only works with integers. E.g. -1 day will produce \"yesterday\",\n                // but -1.1 days will produce \"-1.1 days\". Rounding before formatting is\n                // not desired, as the given dates might cross a threshold were the\n                // output isn't correct anymore. Example: 2024-01-08T23:00:00.000Z and\n                // 2024-01-08T01:00:00.000Z would produce \"yesterday\", which is not the\n                // case. By using `always` we can ensure correct output. The only exception\n                // is the formatting of times <1 second as \"now\".\n                numeric: unit === \"second\" ? \"auto\" : \"always\"\n            }).format(value, unit);\n        } catch (error) {\n            onError(new initializeConfig.IntlError(initializeConfig.IntlErrorCode.FORMATTING_ERROR, error.message));\n            return String(date);\n        }\n    }\n    function list(value, formatOrOptions) {\n        const serializedValue = [];\n        const richValues = new Map();\n        // `formatToParts` only accepts strings, therefore we have to temporarily\n        // replace React elements with a placeholder ID that can be used to retrieve\n        // the original value afterwards.\n        let index = 0;\n        for (const item of value){\n            let serializedItem;\n            if (typeof item === \"object\") {\n                serializedItem = String(index);\n                richValues.set(serializedItem, item);\n            } else {\n                serializedItem = String(item);\n            }\n            serializedValue.push(serializedItem);\n            index++;\n        }\n        return getFormattedValue(formatOrOptions, formats === null || formats === void 0 ? void 0 : formats.list, // @ts-expect-error -- `richValues.size` is used to determine the return type, but TypeScript can't infer the meaning of this correctly\n        (options)=>{\n            const result = new Intl.ListFormat(locale, options).formatToParts(serializedValue).map((part)=>part.type === \"literal\" ? part.value : richValues.get(part.value) || part.value);\n            if (richValues.size > 0) {\n                return result;\n            } else {\n                return result.join(\"\");\n            }\n        }, ()=>String(value));\n    }\n    return {\n        dateTime,\n        number,\n        relativeTime,\n        list\n    };\n}\nexports.createBaseTranslator = createBaseTranslator;\nexports.createFormatter = createFormatter;\nexports.resolveNamespace = resolveNamespace;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9jcmVhdGVGb3JtYXR0ZXItNGNlNmY2YzguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxvQkFBb0JDLG1CQUFPQSxDQUFDO0FBQ2hDLElBQUlDLFFBQVFELG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlFLG1CQUFtQkYsbUJBQU9BLENBQUM7QUFFL0IsU0FBU0csZ0JBQWlCQyxDQUFDO0lBQUksT0FBT0EsS0FBS0EsRUFBRUMsVUFBVSxHQUFHRCxJQUFJO1FBQUVFLFNBQVNGO0lBQUU7QUFBRztBQUU5RSxJQUFJRyw2QkFBNkIsV0FBVyxHQUFFSixnQkFBZ0JKO0FBRTlELHdFQUF3RTtBQUN4RSxTQUFTUyxxQkFBcUJDLE9BQU8sRUFBRUMsUUFBUTtJQUM3QyxJQUFJLENBQUNELFNBQVMsT0FBT0E7SUFFckIsNEZBQTRGO0lBQzVGLHNIQUFzSDtJQUN0SCxPQUFPRSxPQUFPQyxJQUFJLENBQUNILFNBQVNJLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQztRQUN2Q0QsR0FBRyxDQUFDQyxJQUFJLEdBQUc7WUFDVEw7WUFDQSxHQUFHRCxPQUFPLENBQUNNLElBQUk7UUFDakI7UUFDQSxPQUFPRDtJQUNULEdBQUcsQ0FBQztBQUNOO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU0Usa0NBQWtDUCxPQUFPLEVBQUVDLFFBQVE7SUFDMUQsTUFBTU8sc0JBQXNCUCxXQUFXO1FBQ3JDLEdBQUdELE9BQU87UUFDVlMsVUFBVVYscUJBQXFCQyxRQUFRUyxRQUFRLEVBQUVSO0lBQ25ELElBQUlEO0lBQ0osTUFBTVUsaUJBQWlCWiwyQkFBMkJELE9BQU8sQ0FBQ0csT0FBTyxDQUFDVyxJQUFJO0lBQ3RFLE1BQU1DLHFCQUFxQlgsV0FBV0YscUJBQXFCVyxnQkFBZ0JULFlBQVlTO0lBQ3ZGLE1BQU1HLGlCQUFpQmYsMkJBQTJCRCxPQUFPLENBQUNHLE9BQU8sQ0FBQ2MsSUFBSTtJQUN0RSxNQUFNQyxx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Q1AsaUJBQWlCUSxHQUFHLENBQUMvSSxDQUFBQSxPQUFRQSxLQUFLZ0osSUFBSSxLQUFLLFlBQVloSixLQUFLUSxLQUFLLEdBQUdnSSxXQUFXekYsR0FBRyxDQUFDL0MsS0FBS1EsS0FBSyxLQUFLUixLQUFLUSxLQUFLO1lBQzlLLElBQUlnSSxXQUFXUyxJQUFJLEdBQUcsR0FBRztnQkFDdkIsT0FBT3RJO1lBQ1QsT0FBTztnQkFDTCxPQUFPQSxPQUFPdUksSUFBSSxDQUFDO1lBQ3JCO1FBQ0YsR0FBRyxJQUFNdEcsT0FBT3BDO0lBQ2xCO0lBQ0EsT0FBTztRQUNMMUI7UUFDQTZJO1FBQ0FLO1FBQ0FNO0lBQ0Y7QUFDRjtBQUVBYSw0QkFBNEIsR0FBR3JIO0FBQy9CcUgsdUJBQXVCLEdBQUd0QztBQUMxQnNDLHdCQUF3QixHQUFHekUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wd2Etc2Fhcy8uL25vZGVfbW9kdWxlcy91c2UtaW50bC9kaXN0L2RldmVsb3BtZW50L2NyZWF0ZUZvcm1hdHRlci00Y2U2ZjZjOC5qcz8wNDkxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIEludGxNZXNzYWdlRm9ybWF0ID0gcmVxdWlyZSgnaW50bC1tZXNzYWdlZm9ybWF0Jyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGluaXRpYWxpemVDb25maWcgPSByZXF1aXJlKCcuL2luaXRpYWxpemVDb25maWctYzUwM2UyMTUuanMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChlKSB7IHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7IGRlZmF1bHQ6IGUgfTsgfVxuXG52YXIgSW50bE1lc3NhZ2VGb3JtYXRfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0KEludGxNZXNzYWdlRm9ybWF0KTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1uYW1lZC1hcy1kZWZhdWx0IC0tIEZhbHNlIHBvc2l0aXZlXG5mdW5jdGlvbiBzZXRUaW1lWm9uZUluRm9ybWF0cyhmb3JtYXRzLCB0aW1lWm9uZSkge1xuICBpZiAoIWZvcm1hdHMpIHJldHVybiBmb3JtYXRzO1xuXG4gIC8vIFRoZSBvbmx5IHdheSB0byBzZXQgYSB0aW1lIHpvbmUgd2l0aCBgaW50bC1tZXNzYWdlZm9ybWF0YCBpcyB0byBtZXJnZSBpdCBpbnRvIHRoZSBmb3JtYXRzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mb3JtYXRqcy9mb3JtYXRqcy9ibG9iLzgyNTZjNTI3MTUwNWNmMjYwNmU0OGUzYzk3ZWNkZDE2ZWRlNGYxYjUvcGFja2FnZXMvaW50bC9zcmMvbWVzc2FnZS50cyNMMTVcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGZvcm1hdHMpLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICBhY2Nba2V5XSA9IHtcbiAgICAgIHRpbWVab25lLFxuICAgICAgLi4uZm9ybWF0c1trZXldXG4gICAgfTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG5cbi8qKlxuICogYGludGwtbWVzc2FnZWZvcm1hdGAgdXNlcyBzZXBhcmF0ZSBrZXlzIGZvciBgZGF0ZWAgYW5kIGB0aW1lYCwgYnV0IHRoZXJlJ3NcbiAqIG9ubHkgb25lIG5hdGl2ZSBBUEk6IGBJbnRsLkRhdGVUaW1lRm9ybWF0YC4gQWRkaXRpb25hbGx5IHlvdSBtaWdodCB3YW50IHRvXG4gKiBpbmNsdWRlIGJvdGggYSB0aW1lIGFuZCBhIGRhdGUgaW4gYSB2YWx1ZSwgdGhlcmVmb3JlIHRoZSBzZXBhcmF0aW9uIGRvZXNuJ3RcbiAqIHNlZW0gc28gdXNlZnVsLiBXZSBvZmZlciBhIHNpbmdsZSBgZGF0ZVRpbWVgIG5hbWVzcGFjZSBpbnN0ZWFkLCBidXQgd2UgaGF2ZVxuICogdG8gY29udmVydCB0aGUgZm9ybWF0IGJlZm9yZSBgaW50bC1tZXNzYWdlZm9ybWF0YCBjYW4gYmUgdXNlZC5cbiAqL1xuZnVuY3Rpb24gY29udmVydEZvcm1hdHNUb0ludGxNZXNzYWdlRm9ybWF0KGZvcm1hdHMsIHRpbWVab25lKSB7XG4gIGNvbnN0IGZvcm1hdHNXaXRoVGltZVpvbmUgPSB0aW1lWm9uZSA/IHtcbiAgICAuLi5mb3JtYXRzLFxuICAgIGRhdGVUaW1lOiBzZXRUaW1lWm9uZUluRm9ybWF0cyhmb3JtYXRzLmRhdGVUaW1lLCB0aW1lWm9uZSlcbiAgfSA6IGZvcm1hdHM7XG4gIGNvbnN0IG1mRGF0ZURlZmF1bHRzID0gSW50bE1lc3NhZ2VGb3JtYXRfX2RlZmF1bHQuZGVmYXVsdC5mb3JtYXRzLmRhdGU7XG4gIGNvbnN0IGRlZmF1bHREYXRlRm9ybWF0cyA9IHRpbWVab25lID8gc2V0VGltZVpvbmVJbkZvcm1hdHMobWZEYXRlRGVmYXVsdHMsIHRpbWVab25lKSA6IG1mRGF0ZURlZmF1bHRzO1xuICBjb25zdCBtZlRpbWVEZWZhdWx0cyA9IEludGxNZXNzYWdlRm9ybWF0X19kZWZhdWx0LmRlZmF1bHQuZm9ybWF0cy50aW1lO1xuICBjb25zdCBkZWZhdWx0VGltZUZvcm1hdHMgPSB0aW1lWm9uZSA/IHNldFRpbWVab25lSW5Gb3JtYXRzKG1mVGltZURlZmF1bHRzLCB0aW1lWm9uZSkgOiBtZlRpbWVEZWZhdWx0cztcbiAgcmV0dXJuIHtcbiAgICAuLi5mb3JtYXRzV2l0aFRpbWVab25lLFxuICAgIGRhdGU6IHtcbiAgICAgIC4uLmRlZmF1bHREYXRlRm9ybWF0cyxcbiAgICAgIC4uLihmb3JtYXRzV2l0aFRpbWVab25lID09PSBudWxsIHx8IGZvcm1hdHNXaXRoVGltZVpvbmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcm1hdHNXaXRoVGltZVpvbmUuZGF0ZVRpbWUpXG4gICAgfSxcbiAgICB0aW1lOiB7XG4gICAgICAuLi5kZWZhdWx0VGltZUZvcm1hdHMsXG4gICAgICAuLi4oZm9ybWF0c1dpdGhUaW1lWm9uZSA9PT0gbnVsbCB8fCBmb3JtYXRzV2l0aFRpbWVab25lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb3JtYXRzV2l0aFRpbWVab25lLmRhdGVUaW1lKVxuICAgIH1cbiAgfTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1uYW1lZC1hcy1kZWZhdWx0IC0tIEZhbHNlIHBvc2l0aXZlXG5mdW5jdGlvbiByZXNvbHZlUGF0aChsb2NhbGUsIG1lc3NhZ2VzLCBrZXksIG5hbWVzcGFjZSkge1xuICBjb25zdCBmdWxsS2V5ID0gaW5pdGlhbGl6ZUNvbmZpZy5qb2luUGF0aChuYW1lc3BhY2UsIGtleSk7XG4gIGlmICghbWVzc2FnZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBtZXNzYWdlcyBhdmFpbGFibGUgYXQgYFwiLmNvbmNhdChuYW1lc3BhY2UsIFwiYC5cIikgKTtcbiAgfVxuICBsZXQgbWVzc2FnZSA9IG1lc3NhZ2VzO1xuICBrZXkuc3BsaXQoJy4nKS5mb3JFYWNoKHBhcnQgPT4ge1xuICAgIGNvbnN0IG5leHQgPSBtZXNzYWdlW3BhcnRdO1xuICAgIGlmIChwYXJ0ID09IG51bGwgfHwgbmV4dCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcmVzb2x2ZSBgXCIuY29uY2F0KGZ1bGxLZXksIFwiYCBpbiBtZXNzYWdlcyBmb3IgbG9jYWxlIGBcIikuY29uY2F0KGxvY2FsZSwgXCJgLlwiKSApO1xuICAgIH1cbiAgICBtZXNzYWdlID0gbmV4dDtcbiAgfSk7XG4gIHJldHVybiBtZXNzYWdlO1xufVxuZnVuY3Rpb24gcHJlcGFyZVRyYW5zbGF0aW9uVmFsdWVzKHZhbHVlcykge1xuICBpZiAoT2JqZWN0LmtleXModmFsdWVzKS5sZW5ndGggPT09IDApIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2Zvcm1hdGpzL2Zvcm1hdGpzL2lzc3Vlcy8xNDY3XG4gIGNvbnN0IHRyYW5zZm9ybWVkVmFsdWVzID0ge307XG4gIE9iamVjdC5rZXlzKHZhbHVlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNba2V5XTtcbiAgICBsZXQgdHJhbnNmb3JtZWQ7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdHJhbnNmb3JtZWQgPSBjaHVua3MgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZShjaHVua3MpO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmlzVmFsaWRFbGVtZW50KHJlc3VsdCkgPyAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KHJlc3VsdCwge1xuICAgICAgICAgIGtleToga2V5ICsgaW5kZXgrK1xuICAgICAgICB9KSA6IHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zZm9ybWVkID0gdmFsdWU7XG4gICAgfVxuICAgIHRyYW5zZm9ybWVkVmFsdWVzW2tleV0gPSB0cmFuc2Zvcm1lZDtcbiAgfSk7XG4gIHJldHVybiB0cmFuc2Zvcm1lZFZhbHVlcztcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2VzT3JFcnJvcihsb2NhbGUsIG1lc3NhZ2VzLCBuYW1lc3BhY2UpIHtcbiAgbGV0IG9uRXJyb3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGluaXRpYWxpemVDb25maWcuZGVmYXVsdE9uRXJyb3I7XG4gIHRyeSB7XG4gICAgaWYgKCFtZXNzYWdlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gbWVzc2FnZXMgd2VyZSBjb25maWd1cmVkIG9uIHRoZSBwcm92aWRlci5cIiApO1xuICAgIH1cbiAgICBjb25zdCByZXRyaWV2ZWRNZXNzYWdlcyA9IG5hbWVzcGFjZSA/IHJlc29sdmVQYXRoKGxvY2FsZSwgbWVzc2FnZXMsIG5hbWVzcGFjZSkgOiBtZXNzYWdlcztcbiAgICBpZiAoIXJldHJpZXZlZE1lc3NhZ2VzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBtZXNzYWdlcyBmb3IgbmFtZXNwYWNlIGBcIi5jb25jYXQobmFtZXNwYWNlLCBcImAgZm91bmQuXCIpICk7XG4gICAgfVxuICAgIHJldHVybiByZXRyaWV2ZWRNZXNzYWdlcztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBpbnRsRXJyb3IgPSBuZXcgaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3IoaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3JDb2RlLk1JU1NJTkdfTUVTU0FHRSwgZXJyb3IubWVzc2FnZSk7XG4gICAgb25FcnJvcihpbnRsRXJyb3IpO1xuICAgIHJldHVybiBpbnRsRXJyb3I7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFBsYWluTWVzc2FnZShjYW5kaWRhdGUsIHZhbHVlcykge1xuICBpZiAodmFsdWVzKSByZXR1cm4gdW5kZWZpbmVkO1xuICBjb25zdCB1bmVzY2FwZWRNZXNzYWdlID0gY2FuZGlkYXRlLnJlcGxhY2UoLycoW3t9XSkvZ2ksICckMScpO1xuXG4gIC8vIFBsYWNlaG9sZGVycyBjYW4gYmUgaW4gdGhlIG1lc3NhZ2UgaWYgdGhlcmUgYXJlIGRlZmF1bHQgdmFsdWVzLFxuICAvLyBvciBpZiB0aGUgdXNlciBoYXMgZm9yZ290dGVuIHRvIHByb3ZpZGUgdmFsdWVzLiBJbiB0aGUgbGF0dGVyXG4gIC8vIGNhc2Ugd2UgbmVlZCB0byBjb21waWxlIHRoZSBtZXNzYWdlIHRvIHJlY2VpdmUgYW4gZXJyb3IuXG4gIGNvbnN0IGhhc1BsYWNlaG9sZGVycyA9IC88fHsvLnRlc3QodW5lc2NhcGVkTWVzc2FnZSk7XG4gIGlmICghaGFzUGxhY2Vob2xkZXJzKSB7XG4gICAgcmV0dXJuIHVuZXNjYXBlZE1lc3NhZ2U7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VUcmFuc2xhdG9yKGNvbmZpZykge1xuICBjb25zdCBtZXNzYWdlc09yRXJyb3IgPSBnZXRNZXNzYWdlc09yRXJyb3IoY29uZmlnLmxvY2FsZSwgY29uZmlnLm1lc3NhZ2VzLCBjb25maWcubmFtZXNwYWNlLCBjb25maWcub25FcnJvcik7XG4gIHJldHVybiBjcmVhdGVCYXNlVHJhbnNsYXRvckltcGwoe1xuICAgIC4uLmNvbmZpZyxcbiAgICBtZXNzYWdlc09yRXJyb3JcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVCYXNlVHJhbnNsYXRvckltcGwoX3JlZikge1xuICBsZXQge1xuICAgIGRlZmF1bHRUcmFuc2xhdGlvblZhbHVlcyxcbiAgICBmb3JtYXRzOiBnbG9iYWxGb3JtYXRzLFxuICAgIGdldE1lc3NhZ2VGYWxsYmFjayA9IGluaXRpYWxpemVDb25maWcuZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjayxcbiAgICBsb2NhbGUsXG4gICAgbWVzc2FnZUZvcm1hdENhY2hlLFxuICAgIG1lc3NhZ2VzT3JFcnJvcixcbiAgICBuYW1lc3BhY2UsXG4gICAgb25FcnJvcixcbiAgICB0aW1lWm9uZVxuICB9ID0gX3JlZjtcbiAgZnVuY3Rpb24gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBjb2RlLCBtZXNzYWdlKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3IoY29kZSwgbWVzc2FnZSk7XG4gICAgb25FcnJvcihlcnJvcik7XG4gICAgcmV0dXJuIGdldE1lc3NhZ2VGYWxsYmFjayh7XG4gICAgICBlcnJvcixcbiAgICAgIGtleSxcbiAgICAgIG5hbWVzcGFjZVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZUJhc2VGbiggLyoqIFVzZSBhIGRvdCB0byBpbmRpY2F0ZSBhIGxldmVsIG9mIG5lc3RpbmcgKGUuZy4gYG5hbWVzcGFjZS5uZXN0ZWRMYWJlbGApLiAqL1xuICBrZXksIC8qKiBLZXkgdmFsdWUgcGFpcnMgZm9yIHZhbHVlcyB0byBpbnRlcnBvbGF0ZSBpbnRvIHRoZSBtZXNzYWdlLiAqL1xuICB2YWx1ZXMsIC8qKiBQcm92aWRlIGN1c3RvbSBmb3JtYXRzIGZvciBudW1iZXJzLCBkYXRlcyBhbmQgdGltZXMuICovXG4gIGZvcm1hdHMpIHtcbiAgICBpZiAobWVzc2FnZXNPckVycm9yIGluc3RhbmNlb2YgaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3IpIHtcbiAgICAgIC8vIFdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgYWJvdXQgdGhpcyBkdXJpbmcgcmVuZGVyXG4gICAgICByZXR1cm4gZ2V0TWVzc2FnZUZhbGxiYWNrKHtcbiAgICAgICAgZXJyb3I6IG1lc3NhZ2VzT3JFcnJvcixcbiAgICAgICAga2V5LFxuICAgICAgICBuYW1lc3BhY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlcyA9IG1lc3NhZ2VzT3JFcnJvcjtcbiAgICBsZXQgbWVzc2FnZTtcbiAgICB0cnkge1xuICAgICAgbWVzc2FnZSA9IHJlc29sdmVQYXRoKGxvY2FsZSwgbWVzc2FnZXMsIGtleSwgbmFtZXNwYWNlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3JDb2RlLk1JU1NJTkdfTUVTU0FHRSwgZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlS2V5ID0gaW5pdGlhbGl6ZUNvbmZpZy5qb2luUGF0aChsb2NhbGUsIG5hbWVzcGFjZSwga2V5LCBTdHJpbmcobWVzc2FnZSkpO1xuICAgIGxldCBtZXNzYWdlRm9ybWF0O1xuICAgIGlmIChtZXNzYWdlRm9ybWF0Q2FjaGUgIT09IG51bGwgJiYgbWVzc2FnZUZvcm1hdENhY2hlICE9PSB2b2lkIDAgJiYgbWVzc2FnZUZvcm1hdENhY2hlLmhhcyhjYWNoZUtleSkpIHtcbiAgICAgIG1lc3NhZ2VGb3JtYXQgPSBtZXNzYWdlRm9ybWF0Q2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBsZXQgY29kZSwgZXJyb3JNZXNzYWdlO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtZXNzYWdlKSkge1xuICAgICAgICAgIGNvZGUgPSBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuSU5WQUxJRF9NRVNTQUdFO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IFwiTWVzc2FnZSBhdCBgXCIuY29uY2F0KGluaXRpYWxpemVDb25maWcuam9pblBhdGgobmFtZXNwYWNlLCBrZXkpLCBcImAgcmVzb2x2ZWQgdG8gYW4gYXJyYXksIGJ1dCBvbmx5IHN0cmluZ3MgYXJlIHN1cHBvcnRlZC4gU2VlIGh0dHBzOi8vbmV4dC1pbnRsLWRvY3MudmVyY2VsLmFwcC9kb2NzL3VzYWdlL21lc3NhZ2VzI2FycmF5cy1vZi1tZXNzYWdlc1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29kZSA9IGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZS5JTlNVRkZJQ0lFTlRfUEFUSDtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBcIk1lc3NhZ2UgYXQgYFwiLmNvbmNhdChpbml0aWFsaXplQ29uZmlnLmpvaW5QYXRoKG5hbWVzcGFjZSwga2V5KSwgXCJgIHJlc29sdmVkIHRvIGFuIG9iamVjdCwgYnV0IG9ubHkgc3RyaW5ncyBhcmUgc3VwcG9ydGVkLiBVc2UgYSBgLmAgdG8gcmV0cmlldmUgbmVzdGVkIG1lc3NhZ2VzLiBTZWUgaHR0cHM6Ly9uZXh0LWludGwtZG9jcy52ZXJjZWwuYXBwL2RvY3MvdXNhZ2UvbWVzc2FnZXMjc3RydWN0dXJpbmctbWVzc2FnZXNcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIGNvZGUsIGVycm9yTWVzc2FnZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEhvdCBwYXRoIHRoYXQgYXZvaWRzIGNyZWF0aW5nIGFuIGBJbnRsTWVzc2FnZUZvcm1hdGAgaW5zdGFuY2VcbiAgICAgIGNvbnN0IHBsYWluTWVzc2FnZSA9IGdldFBsYWluTWVzc2FnZShtZXNzYWdlLCB2YWx1ZXMpO1xuICAgICAgaWYgKHBsYWluTWVzc2FnZSkgcmV0dXJuIHBsYWluTWVzc2FnZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1lc3NhZ2VGb3JtYXQgPSBuZXcgSW50bE1lc3NhZ2VGb3JtYXRfX2RlZmF1bHQuZGVmYXVsdChtZXNzYWdlLCBsb2NhbGUsIGNvbnZlcnRGb3JtYXRzVG9JbnRsTWVzc2FnZUZvcm1hdCh7XG4gICAgICAgICAgLi4uZ2xvYmFsRm9ybWF0cyxcbiAgICAgICAgICAuLi5mb3JtYXRzXG4gICAgICAgIH0sIHRpbWVab25lKSwge1xuICAgICAgICAgIGZvcm1hdHRlcnM6IHtcbiAgICAgICAgICAgIGdldE51bWJlckZvcm1hdChsb2NhbGVzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlcywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0RGF0ZVRpbWVGb3JtYXQobG9jYWxlcywgb3B0aW9ucykge1xuICAgICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vZm9ybWF0anMvZm9ybWF0anMvaXNzdWVzLzQyNzlcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZXMsIHtcbiAgICAgICAgICAgICAgICB0aW1lWm9uZSxcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFBsdXJhbFJ1bGVzKGxvY2FsZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRsLlBsdXJhbFJ1bGVzKGxvY2FsZXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCB0aHJvd25FcnJvciA9IGVycm9yO1xuICAgICAgICByZXR1cm4gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuSU5WQUxJRF9NRVNTQUdFLCB0aHJvd25FcnJvci5tZXNzYWdlICsgKCdvcmlnaW5hbE1lc3NhZ2UnIGluIHRocm93bkVycm9yID8gXCIgKFwiLmNvbmNhdCh0aHJvd25FcnJvci5vcmlnaW5hbE1lc3NhZ2UsIFwiKVwiKSA6ICcnKSApO1xuICAgICAgfVxuICAgICAgbWVzc2FnZUZvcm1hdENhY2hlID09PSBudWxsIHx8IG1lc3NhZ2VGb3JtYXRDYWNoZSA9PT0gdm9pZCAwIHx8IG1lc3NhZ2VGb3JtYXRDYWNoZS5zZXQoY2FjaGVLZXksIG1lc3NhZ2VGb3JtYXQpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgZm9ybWF0dGVkTWVzc2FnZSA9IG1lc3NhZ2VGb3JtYXQuZm9ybWF0KFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgaW50bC1tZXNzYWdlZm9ybWF0YCBleHBlY3RzIGEgZGlmZmVyZW50IGZvcm1hdFxuICAgICAgLy8gZm9yIHJpY2ggdGV4dCBlbGVtZW50cyBzaW5jZSBhIHJlY2VudCBtaW5vciB1cGRhdGUuIFRoaXNcbiAgICAgIC8vIG5lZWRzIHRvIGJlIGV2YWx1YXRlZCBpbiBkZXRhaWwsIHBvc3NpYmx5IGFsc28gaW4gcmVnYXJkc1xuICAgICAgLy8gdG8gYmUgYWJsZSB0byBmb3JtYXQgdG8gcGFydHMuXG4gICAgICBwcmVwYXJlVHJhbnNsYXRpb25WYWx1ZXMoe1xuICAgICAgICAuLi5kZWZhdWx0VHJhbnNsYXRpb25WYWx1ZXMsXG4gICAgICAgIC4uLnZhbHVlc1xuICAgICAgfSkpO1xuICAgICAgaWYgKGZvcm1hdHRlZE1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZm9ybWF0IGBcIi5jb25jYXQoa2V5LCBcImAgaW4gXCIpLmNvbmNhdChuYW1lc3BhY2UgPyBcIm5hbWVzcGFjZSBgXCIuY29uY2F0KG5hbWVzcGFjZSwgXCJgXCIpIDogJ21lc3NhZ2VzJykgKTtcbiAgICAgIH1cblxuICAgICAgLy8gTGltaXQgdGhlIGZ1bmN0aW9uIHNpZ25hdHVyZSB0byByZXR1cm4gc3RyaW5ncyBvciBSZWFjdCBlbGVtZW50c1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5pc1ZhbGlkRWxlbWVudChmb3JtYXR0ZWRNZXNzYWdlKSB8fFxuICAgICAgLy8gQXJyYXlzIG9mIFJlYWN0IGVsZW1lbnRzXG4gICAgICBBcnJheS5pc0FycmF5KGZvcm1hdHRlZE1lc3NhZ2UpIHx8IHR5cGVvZiBmb3JtYXR0ZWRNZXNzYWdlID09PSAnc3RyaW5nJyA/IGZvcm1hdHRlZE1lc3NhZ2UgOiBTdHJpbmcoZm9ybWF0dGVkTWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZS5GT1JNQVRUSU5HX0VSUk9SLCBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHJhbnNsYXRlRm4oIC8qKiBVc2UgYSBkb3QgdG8gaW5kaWNhdGUgYSBsZXZlbCBvZiBuZXN0aW5nIChlLmcuIGBuYW1lc3BhY2UubmVzdGVkTGFiZWxgKS4gKi9cbiAga2V5LCAvKiogS2V5IHZhbHVlIHBhaXJzIGZvciB2YWx1ZXMgdG8gaW50ZXJwb2xhdGUgaW50byB0aGUgbWVzc2FnZS4gKi9cbiAgdmFsdWVzLCAvKiogUHJvdmlkZSBjdXN0b20gZm9ybWF0cyBmb3IgbnVtYmVycywgZGF0ZXMgYW5kIHRpbWVzLiAqL1xuICBmb3JtYXRzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdHJhbnNsYXRlQmFzZUZuKGtleSwgdmFsdWVzLCBmb3JtYXRzKTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZS5JTlZBTElEX01FU1NBR0UsIFwiVGhlIG1lc3NhZ2UgYFwiLmNvbmNhdChrZXksIFwiYCBpbiBcIikuY29uY2F0KG5hbWVzcGFjZSA/IFwibmFtZXNwYWNlIGBcIi5jb25jYXQobmFtZXNwYWNlLCBcImBcIikgOiAnbWVzc2FnZXMnLCBcIiBkaWRuJ3QgcmVzb2x2ZSB0byBhIHN0cmluZy4gSWYgeW91IHdhbnQgdG8gZm9ybWF0IHJpY2ggdGV4dCwgdXNlIGB0LnJpY2hgIGluc3RlYWQuXCIpICk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdHJhbnNsYXRlRm4ucmljaCA9IHRyYW5zbGF0ZUJhc2VGbjtcblxuICAvLyBBdWdtZW50IGB0cmFuc2xhdGVCYXNlRm5gIHRvIHJldHVybiBwbGFpbiBzdHJpbmdzXG4gIHRyYW5zbGF0ZUZuLm1hcmt1cCA9IChrZXksIHZhbHVlcywgZm9ybWF0cykgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRyYW5zbGF0ZUJhc2VGbihrZXksXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBgTWFya3VwVHJhbnNsYXRpb25WYWx1ZXNgIGlzIHByYWN0aWNhbGx5IGEgc3ViIHR5cGVcbiAgICAvLyBvZiBgUmljaFRyYW5zbGF0aW9uVmFsdWVzYCBidXQgVHlwZVNjcmlwdCBpc24ndCBzbWFydCBlbm91Z2ggaGVyZS5cbiAgICB2YWx1ZXMsIGZvcm1hdHMpO1xuXG4gICAgLy8gV2hlbiBvbmx5IHN0cmluZyBjaHVua3MgYXJlIHByb3ZpZGVkIHRvIHRoZSBwYXJzZXIsIG9ubHlcbiAgICAvLyBzdHJpbmdzIHNob3VsZCBiZSByZXR1cm5lZCBoZXJlLiBOb3RlIHRoYXQgd2UgbmVlZCBhIHJ1bnRpbWVcbiAgICAvLyBjaGVjayBmb3IgdGhpcyBzaW5jZSByaWNoIHRleHQgdmFsdWVzIGNvdWxkIGJlIGFjY2lkZW50YWxseVxuICAgIC8vIGluaGVyaXRlZCBmcm9tIGBkZWZhdWx0VHJhbnNsYXRpb25WYWx1ZXNgLlxuICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3IoaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3JDb2RlLkZPUk1BVFRJTkdfRVJST1IsIFwiYHQubWFya3VwYCBvbmx5IGFjY2VwdHMgZnVuY3Rpb25zIGZvciBmb3JtYXR0aW5nIHRoYXQgcmVjZWl2ZSBhbmQgcmV0dXJuIHN0cmluZ3MuXFxuXFxuRS5nLiB0Lm1hcmt1cCgnbWFya3VwJywge2I6IChjaHVua3MpID0+IGA8Yj4ke2NodW5rc308L2I+YH0pXCIgKTtcbiAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIGdldE1lc3NhZ2VGYWxsYmFjayh7XG4gICAgICAgIGVycm9yLFxuICAgICAgICBrZXksXG4gICAgICAgIG5hbWVzcGFjZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHRyYW5zbGF0ZUZuLnJhdyA9IGtleSA9PiB7XG4gICAgaWYgKG1lc3NhZ2VzT3JFcnJvciBpbnN0YW5jZW9mIGluaXRpYWxpemVDb25maWcuSW50bEVycm9yKSB7XG4gICAgICAvLyBXZSBoYXZlIGFscmVhZHkgd2FybmVkIGFib3V0IHRoaXMgZHVyaW5nIHJlbmRlclxuICAgICAgcmV0dXJuIGdldE1lc3NhZ2VGYWxsYmFjayh7XG4gICAgICAgIGVycm9yOiBtZXNzYWdlc09yRXJyb3IsXG4gICAgICAgIGtleSxcbiAgICAgICAgbmFtZXNwYWNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZXMgPSBtZXNzYWdlc09yRXJyb3I7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiByZXNvbHZlUGF0aChsb2NhbGUsIG1lc3NhZ2VzLCBrZXksIG5hbWVzcGFjZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZS5NSVNTSU5HX01FU1NBR0UsIGVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHRyYW5zbGF0ZUZuO1xufVxuXG4vKipcbiAqIEZvciB0aGUgc3RyaWN0bHkgdHlwZWQgbWVzc2FnZXMgdG8gd29yayB3ZSBoYXZlIHRvIHdyYXAgdGhlIG5hbWVzcGFjZSBpbnRvXG4gKiBhIG1hbmRhdG9yeSBwcmVmaXguIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNzE1Mjk1NzUvMzQzMDQ1XG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVOYW1lc3BhY2UobmFtZXNwYWNlLCBuYW1lc3BhY2VQcmVmaXgpIHtcbiAgcmV0dXJuIG5hbWVzcGFjZSA9PT0gbmFtZXNwYWNlUHJlZml4ID8gdW5kZWZpbmVkIDogbmFtZXNwYWNlLnNsaWNlKChuYW1lc3BhY2VQcmVmaXggKyAnLicpLmxlbmd0aCk7XG59XG5cbmNvbnN0IFNFQ09ORCA9IDE7XG5jb25zdCBNSU5VVEUgPSBTRUNPTkQgKiA2MDtcbmNvbnN0IEhPVVIgPSBNSU5VVEUgKiA2MDtcbmNvbnN0IERBWSA9IEhPVVIgKiAyNDtcbmNvbnN0IFdFRUsgPSBEQVkgKiA3O1xuY29uc3QgTU9OVEggPSBEQVkgKiAoMzY1IC8gMTIpOyAvLyBBcHByb3hpbWF0aW9uXG5jb25zdCBRVUFSVEVSID0gTU9OVEggKiAzO1xuY29uc3QgWUVBUiA9IERBWSAqIDM2NTtcbmNvbnN0IFVOSVRfU0VDT05EUyA9IHtcbiAgc2Vjb25kOiBTRUNPTkQsXG4gIHNlY29uZHM6IFNFQ09ORCxcbiAgbWludXRlOiBNSU5VVEUsXG4gIG1pbnV0ZXM6IE1JTlVURSxcbiAgaG91cjogSE9VUixcbiAgaG91cnM6IEhPVVIsXG4gIGRheTogREFZLFxuICBkYXlzOiBEQVksXG4gIHdlZWs6IFdFRUssXG4gIHdlZWtzOiBXRUVLLFxuICBtb250aDogTU9OVEgsXG4gIG1vbnRoczogTU9OVEgsXG4gIHF1YXJ0ZXI6IFFVQVJURVIsXG4gIHF1YXJ0ZXJzOiBRVUFSVEVSLFxuICB5ZWFyOiBZRUFSLFxuICB5ZWFyczogWUVBUlxufTtcbmZ1bmN0aW9uIHJlc29sdmVSZWxhdGl2ZVRpbWVVbml0KHNlY29uZHMpIHtcbiAgY29uc3QgYWJzVmFsdWUgPSBNYXRoLmFicyhzZWNvbmRzKTtcbiAgaWYgKGFic1ZhbHVlIDwgTUlOVVRFKSB7XG4gICAgcmV0dXJuICdzZWNvbmQnO1xuICB9IGVsc2UgaWYgKGFic1ZhbHVlIDwgSE9VUikge1xuICAgIHJldHVybiAnbWludXRlJztcbiAgfSBlbHNlIGlmIChhYnNWYWx1ZSA8IERBWSkge1xuICAgIHJldHVybiAnaG91cic7XG4gIH0gZWxzZSBpZiAoYWJzVmFsdWUgPCBXRUVLKSB7XG4gICAgcmV0dXJuICdkYXknO1xuICB9IGVsc2UgaWYgKGFic1ZhbHVlIDwgTU9OVEgpIHtcbiAgICByZXR1cm4gJ3dlZWsnO1xuICB9IGVsc2UgaWYgKGFic1ZhbHVlIDwgWUVBUikge1xuICAgIHJldHVybiAnbW9udGgnO1xuICB9XG4gIHJldHVybiAneWVhcic7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVSZWxhdGl2ZVRpbWVWYWx1ZShzZWNvbmRzLCB1bml0KSB7XG4gIC8vIFdlIGhhdmUgdG8gcm91bmQgdGhlIHJlc3VsdGluZyB2YWx1ZXMsIGFzIGBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdGBcbiAgLy8gd2lsbCBpbmNsdWRlIGZyYWN0aW9ucyBsaWtlICcyLjEgaG91cnMgYWdvJy5cbiAgcmV0dXJuIE1hdGgucm91bmQoc2Vjb25kcyAvIFVOSVRfU0VDT05EU1t1bml0XSk7XG59XG5mdW5jdGlvbiBjcmVhdGVGb3JtYXR0ZXIoX3JlZikge1xuICBsZXQge1xuICAgIGZvcm1hdHMsXG4gICAgbG9jYWxlLFxuICAgIG5vdzogZ2xvYmFsTm93LFxuICAgIG9uRXJyb3IgPSBpbml0aWFsaXplQ29uZmlnLmRlZmF1bHRPbkVycm9yLFxuICAgIHRpbWVab25lOiBnbG9iYWxUaW1lWm9uZVxuICB9ID0gX3JlZjtcbiAgZnVuY3Rpb24gcmVzb2x2ZUZvcm1hdE9yT3B0aW9ucyh0eXBlRm9ybWF0cywgZm9ybWF0T3JPcHRpb25zKSB7XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgaWYgKHR5cGVvZiBmb3JtYXRPck9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBmb3JtYXROYW1lID0gZm9ybWF0T3JPcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHR5cGVGb3JtYXRzID09PSBudWxsIHx8IHR5cGVGb3JtYXRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0eXBlRm9ybWF0c1tmb3JtYXROYW1lXTtcbiAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvcihpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuTUlTU0lOR19GT1JNQVQsIFwiRm9ybWF0IGBcIi5jb25jYXQoZm9ybWF0TmFtZSwgXCJgIGlzIG5vdCBhdmFpbGFibGUuIFlvdSBjYW4gY29uZmlndXJlIGl0IG9uIHRoZSBwcm92aWRlciBvciBwcm92aWRlIGN1c3RvbSBvcHRpb25zLlwiKSApO1xuICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSBmb3JtYXRPck9wdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG4gIGZ1bmN0aW9uIGdldEZvcm1hdHRlZFZhbHVlKGZvcm1hdE9yT3B0aW9ucywgdHlwZUZvcm1hdHMsIGZvcm1hdHRlciwgZ2V0RmFsbGJhY2spIHtcbiAgICBsZXQgb3B0aW9ucztcbiAgICB0cnkge1xuICAgICAgb3B0aW9ucyA9IHJlc29sdmVGb3JtYXRPck9wdGlvbnModHlwZUZvcm1hdHMsIGZvcm1hdE9yT3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFjaygpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcihvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgb25FcnJvcihuZXcgaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3IoaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3JDb2RlLkZPUk1BVFRJTkdfRVJST1IsIGVycm9yLm1lc3NhZ2UpKTtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkYXRlVGltZSggLyoqIElmIGEgbnVtYmVyIGlzIHN1cHBsaWVkLCB0aGlzIGlzIGludGVycHJldGVkIGFzIGEgVVRDIHRpbWVzdGFtcC4gKi9cbiAgdmFsdWUsXG4gIC8qKiBJZiBhIHRpbWUgem9uZSBpcyBzdXBwbGllZCwgdGhlIGB2YWx1ZWAgaXMgY29udmVydGVkIHRvIHRoYXQgdGltZSB6b25lLlxuICAgKiBPdGhlcndpc2UgdGhlIHVzZXIgdGltZSB6b25lIHdpbGwgYmUgdXNlZC4gKi9cbiAgZm9ybWF0T3JPcHRpb25zKSB7XG4gICAgcmV0dXJuIGdldEZvcm1hdHRlZFZhbHVlKGZvcm1hdE9yT3B0aW9ucywgZm9ybWF0cyA9PT0gbnVsbCB8fCBmb3JtYXRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb3JtYXRzLmRhdGVUaW1lLCBvcHRpb25zID0+IHtcbiAgICAgIHZhciBfb3B0aW9ucztcbiAgICAgIGlmICghKChfb3B0aW9ucyA9IG9wdGlvbnMpICE9PSBudWxsICYmIF9vcHRpb25zICE9PSB2b2lkIDAgJiYgX29wdGlvbnMudGltZVpvbmUpKSB7XG4gICAgICAgIGlmIChnbG9iYWxUaW1lWm9uZSkge1xuICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdGltZVpvbmU6IGdsb2JhbFRpbWVab25lXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbkVycm9yKG5ldyBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvcihpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuRU5WSVJPTk1FTlRfRkFMTEJBQ0ssIFwiVGhlIGB0aW1lWm9uZWAgcGFyYW1ldGVyIHdhc24ndCBwcm92aWRlZCBhbmQgdGhlcmUgaXMgbm8gZ2xvYmFsIGRlZmF1bHQgY29uZmlndXJlZC4gQ29uc2lkZXIgYWRkaW5nIGEgZ2xvYmFsIGRlZmF1bHQgdG8gYXZvaWQgbWFya3VwIG1pc21hdGNoZXMgY2F1c2VkIGJ5IGVudmlyb25tZW50IGRpZmZlcmVuY2VzLiBMZWFybiBtb3JlOiBodHRwczovL25leHQtaW50bC1kb2NzLnZlcmNlbC5hcHAvZG9jcy9jb25maWd1cmF0aW9uI3RpbWUtem9uZVwiICkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXQodmFsdWUpO1xuICAgIH0sICgpID0+IFN0cmluZyh2YWx1ZSkpO1xuICB9XG4gIGZ1bmN0aW9uIG51bWJlcih2YWx1ZSwgZm9ybWF0T3JPcHRpb25zKSB7XG4gICAgcmV0dXJuIGdldEZvcm1hdHRlZFZhbHVlKGZvcm1hdE9yT3B0aW9ucywgZm9ybWF0cyA9PT0gbnVsbCB8fCBmb3JtYXRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb3JtYXRzLm51bWJlciwgb3B0aW9ucyA9PiBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXQodmFsdWUpLCAoKSA9PiBTdHJpbmcodmFsdWUpKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRHbG9iYWxOb3coKSB7XG4gICAgaWYgKGdsb2JhbE5vdykge1xuICAgICAgcmV0dXJuIGdsb2JhbE5vdztcbiAgICB9IGVsc2Uge1xuICAgICAgb25FcnJvcihuZXcgaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3IoaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3JDb2RlLkVOVklST05NRU5UX0ZBTExCQUNLLCBcIlRoZSBgbm93YCBwYXJhbWV0ZXIgd2Fzbid0IHByb3ZpZGVkIGFuZCB0aGVyZSBpcyBubyBnbG9iYWwgZGVmYXVsdCBjb25maWd1cmVkLiBDb25zaWRlciBhZGRpbmcgYSBnbG9iYWwgZGVmYXVsdCB0byBhdm9pZCBtYXJrdXAgbWlzbWF0Y2hlcyBjYXVzZWQgYnkgZW52aXJvbm1lbnQgZGlmZmVyZW5jZXMuIExlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dC1pbnRsLWRvY3MudmVyY2VsLmFwcC9kb2NzL2NvbmZpZ3VyYXRpb24jbm93XCIgKSk7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZXh0cmFjdE5vd0RhdGUobm93T3JPcHRpb25zKSB7XG4gICAgaWYgKG5vd09yT3B0aW9ucyBpbnN0YW5jZW9mIERhdGUgfHwgdHlwZW9mIG5vd09yT3B0aW9ucyA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShub3dPck9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoKG5vd09yT3B0aW9ucyA9PT0gbnVsbCB8fCBub3dPck9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vd09yT3B0aW9ucy5ub3cpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShub3dPck9wdGlvbnMubm93KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEdsb2JhbE5vdygpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbGF0aXZlVGltZSggLyoqIFRoZSBkYXRlIHRpbWUgdGhhdCBuZWVkcyB0byBiZSBmb3JtYXR0ZWQuICovXG4gIGRhdGUsIC8qKiBUaGUgcmVmZXJlbmNlIHBvaW50IGluIHRpbWUgdG8gd2hpY2ggYGRhdGVgIHdpbGwgYmUgZm9ybWF0dGVkIGluIHJlbGF0aW9uIHRvLiAgKi9cbiAgbm93T3JPcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGVEYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgICBjb25zdCBub3dEYXRlID0gZXh0cmFjdE5vd0RhdGUobm93T3JPcHRpb25zKTtcbiAgICAgIGNvbnN0IHNlY29uZHMgPSAoZGF0ZURhdGUuZ2V0VGltZSgpIC0gbm93RGF0ZS5nZXRUaW1lKCkpIC8gMTAwMDtcbiAgICAgIGNvbnN0IHVuaXQgPSB0eXBlb2Ygbm93T3JPcHRpb25zID09PSAnbnVtYmVyJyB8fCBub3dPck9wdGlvbnMgaW5zdGFuY2VvZiBEYXRlIHx8IChub3dPck9wdGlvbnMgPT09IG51bGwgfHwgbm93T3JPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub3dPck9wdGlvbnMudW5pdCkgPT09IHVuZGVmaW5lZCA/IHJlc29sdmVSZWxhdGl2ZVRpbWVVbml0KHNlY29uZHMpIDogbm93T3JPcHRpb25zLnVuaXQ7XG4gICAgICBjb25zdCB2YWx1ZSA9IGNhbGN1bGF0ZVJlbGF0aXZlVGltZVZhbHVlKHNlY29uZHMsIHVuaXQpO1xuICAgICAgcmV0dXJuIG5ldyBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdChsb2NhbGUsIHtcbiAgICAgICAgLy8gYG51bWVyaWM6ICdhdXRvJ2AgY2FuIHRoZW9yZXRpY2FsbHkgcHJvZHVjZSBvdXRwdXQgbGlrZSBcInllc3RlcmRheVwiLFxuICAgICAgICAvLyBidXQgaXQgb25seSB3b3JrcyB3aXRoIGludGVnZXJzLiBFLmcuIC0xIGRheSB3aWxsIHByb2R1Y2UgXCJ5ZXN0ZXJkYXlcIixcbiAgICAgICAgLy8gYnV0IC0xLjEgZGF5cyB3aWxsIHByb2R1Y2UgXCItMS4xIGRheXNcIi4gUm91bmRpbmcgYmVmb3JlIGZvcm1hdHRpbmcgaXNcbiAgICAgICAgLy8gbm90IGRlc2lyZWQsIGFzIHRoZSBnaXZlbiBkYXRlcyBtaWdodCBjcm9zcyBhIHRocmVzaG9sZCB3ZXJlIHRoZVxuICAgICAgICAvLyBvdXRwdXQgaXNuJ3QgY29ycmVjdCBhbnltb3JlLiBFeGFtcGxlOiAyMDI0LTAxLTA4VDIzOjAwOjAwLjAwMFogYW5kXG4gICAgICAgIC8vIDIwMjQtMDEtMDhUMDE6MDA6MDAuMDAwWiB3b3VsZCBwcm9kdWNlIFwieWVzdGVyZGF5XCIsIHdoaWNoIGlzIG5vdCB0aGVcbiAgICAgICAgLy8gY2FzZS4gQnkgdXNpbmcgYGFsd2F5c2Agd2UgY2FuIGVuc3VyZSBjb3JyZWN0IG91dHB1dC4gVGhlIG9ubHkgZXhjZXB0aW9uXG4gICAgICAgIC8vIGlzIHRoZSBmb3JtYXR0aW5nIG9mIHRpbWVzIDwxIHNlY29uZCBhcyBcIm5vd1wiLlxuICAgICAgICBudW1lcmljOiB1bml0ID09PSAnc2Vjb25kJyA/ICdhdXRvJyA6ICdhbHdheXMnXG4gICAgICB9KS5mb3JtYXQodmFsdWUsIHVuaXQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBvbkVycm9yKG5ldyBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvcihpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuRk9STUFUVElOR19FUlJPUiwgZXJyb3IubWVzc2FnZSkpO1xuICAgICAgcmV0dXJuIFN0cmluZyhkYXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbGlzdCh2YWx1ZSwgZm9ybWF0T3JPcHRpb25zKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZFZhbHVlID0gW107XG4gICAgY29uc3QgcmljaFZhbHVlcyA9IG5ldyBNYXAoKTtcblxuICAgIC8vIGBmb3JtYXRUb1BhcnRzYCBvbmx5IGFjY2VwdHMgc3RyaW5ncywgdGhlcmVmb3JlIHdlIGhhdmUgdG8gdGVtcG9yYXJpbHlcbiAgICAvLyByZXBsYWNlIFJlYWN0IGVsZW1lbnRzIHdpdGggYSBwbGFjZWhvbGRlciBJRCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJldHJpZXZlXG4gICAgLy8gdGhlIG9yaWdpbmFsIHZhbHVlIGFmdGVyd2FyZHMuXG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgIGxldCBzZXJpYWxpemVkSXRlbTtcbiAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgc2VyaWFsaXplZEl0ZW0gPSBTdHJpbmcoaW5kZXgpO1xuICAgICAgICByaWNoVmFsdWVzLnNldChzZXJpYWxpemVkSXRlbSwgaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXJpYWxpemVkSXRlbSA9IFN0cmluZyhpdGVtKTtcbiAgICAgIH1cbiAgICAgIHNlcmlhbGl6ZWRWYWx1ZS5wdXNoKHNlcmlhbGl6ZWRJdGVtKTtcbiAgICAgIGluZGV4Kys7XG4gICAgfVxuICAgIHJldHVybiBnZXRGb3JtYXR0ZWRWYWx1ZShmb3JtYXRPck9wdGlvbnMsIGZvcm1hdHMgPT09IG51bGwgfHwgZm9ybWF0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm9ybWF0cy5saXN0LFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gYHJpY2hWYWx1ZXMuc2l6ZWAgaXMgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHJldHVybiB0eXBlLCBidXQgVHlwZVNjcmlwdCBjYW4ndCBpbmZlciB0aGUgbWVhbmluZyBvZiB0aGlzIGNvcnJlY3RseVxuICAgIG9wdGlvbnMgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEludGwuTGlzdEZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdFRvUGFydHMoc2VyaWFsaXplZFZhbHVlKS5tYXAocGFydCA9PiBwYXJ0LnR5cGUgPT09ICdsaXRlcmFsJyA/IHBhcnQudmFsdWUgOiByaWNoVmFsdWVzLmdldChwYXJ0LnZhbHVlKSB8fCBwYXJ0LnZhbHVlKTtcbiAgICAgIGlmIChyaWNoVmFsdWVzLnNpemUgPiAwKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuICAgICAgfVxuICAgIH0sICgpID0+IFN0cmluZyh2YWx1ZSkpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGF0ZVRpbWUsXG4gICAgbnVtYmVyLFxuICAgIHJlbGF0aXZlVGltZSxcbiAgICBsaXN0XG4gIH07XG59XG5cbmV4cG9ydHMuY3JlYXRlQmFzZVRyYW5zbGF0b3IgPSBjcmVhdGVCYXNlVHJhbnNsYXRvcjtcbmV4cG9ydHMuY3JlYXRlRm9ybWF0dGVyID0gY3JlYXRlRm9ybWF0dGVyO1xuZXhwb3J0cy5yZXNvbHZlTmFtZXNwYWNlID0gcmVzb2x2ZU5hbWVzcGFjZTtcbiJdLCJuYW1lcyI6WyJJbnRsTWVzc2FnZUZvcm1hdCIsInJlcXVpcmUiLCJSZWFjdCIsImluaXRpYWxpemVDb25maWciLCJfaW50ZXJvcERlZmF1bHQiLCJlIiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJJbnRsTWVzc2FnZUZvcm1hdF9fZGVmYXVsdCIsInNldFRpbWVab25lSW5Gb3JtYXRzIiwiZm9ybWF0cyIsInRpbWVab25lIiwiT2JqZWN0Iiwia2V5cyIsInJlZHVjZSIsImFjYyIsImtleSIsImNvbnZlcnRGb3JtYXRzVG9JbnRsTWVzc2FnZUZvcm1hdCIsImZvcm1hdHNXaXRoVGltZVpvbmUiLCJkYXRlVGltZSIsIm1mRGF0ZURlZmF1bHRzIiwiZGF0ZSIsImRlZmF1bHREYXRlRm9ybWF0cyIsIm1mVGltZURlZmF1bHRzIiwidGltZSIsImRlZmF1bHRUaW1lRm9ybWF0cyIsInJlc29sdmVQYXRoIiwibG9jYWxlIiwibWVzc2FnZXMiLCJuYW1lc3BhY2UiLCJmdWxsS2V5Iiwiam9pblBhdGgiLCJFcnJvciIsImNvbmNhdCIsIm1lc3NhZ2UiLCJzcGxpdCIsImZvckVhY2giLCJwYXJ0IiwibmV4dCIsInByZXBhcmVUcmFuc2xhdGlvblZhbHVlcyIsInZhbHVlcyIsImxlbmd0aCIsInVuZGVmaW5lZCIsInRyYW5zZm9ybWVkVmFsdWVzIiwiaW5kZXgiLCJ2YWx1ZSIsInRyYW5zZm9ybWVkIiwiY2h1bmtzIiwicmVzdWx0IiwiaXNWYWxpZEVsZW1lbnQiLCJjbG9uZUVsZW1lbnQiLCJnZXRNZXNzYWdlc09yRXJyb3IiLCJvbkVycm9yIiwiYXJndW1lbnRzIiwiZGVmYXVsdE9uRXJyb3IiLCJyZXRyaWV2ZWRNZXNzYWdlcyIsImVycm9yIiwiaW50bEVycm9yIiwiSW50bEVycm9yIiwiSW50bEVycm9yQ29kZSIsIk1JU1NJTkdfTUVTU0FHRSIsImdldFBsYWluTWVzc2FnZSIsImNhbmRpZGF0ZSIsInVuZXNjYXBlZE1lc3NhZ2UiLCJyZXBsYWNlIiwiaGFzUGxhY2Vob2xkZXJzIiwidGVzdCIsImNyZWF0ZUJhc2VUcmFuc2xhdG9yIiwiY29uZmlnIiwibWVzc2FnZXNPckVycm9yIiwiY3JlYXRlQmFzZVRyYW5zbGF0b3JJbXBsIiwiX3JlZiIsImRlZmF1bHRUcmFuc2xhdGlvblZhbHVlcyIsImdsb2JhbEZvcm1hdHMiLCJnZXRNZXNzYWdlRmFsbGJhY2siLCJkZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrIiwibWVzc2FnZUZvcm1hdENhY2hlIiwiZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkiLCJjb2RlIiwidHJhbnNsYXRlQmFzZUZuIiwiY2FjaGVLZXkiLCJTdHJpbmciLCJtZXNzYWdlRm9ybWF0IiwiaGFzIiwiZ2V0IiwiZXJyb3JNZXNzYWdlIiwiQXJyYXkiLCJpc0FycmF5IiwiSU5WQUxJRF9NRVNTQUdFIiwiSU5TVUZGSUNJRU5UX1BBVEgiLCJwbGFpbk1lc3NhZ2UiLCJmb3JtYXR0ZXJzIiwiZ2V0TnVtYmVyRm9ybWF0IiwibG9jYWxlcyIsIm9wdGlvbnMiLCJJbnRsIiwiTnVtYmVyRm9ybWF0IiwiZ2V0RGF0ZVRpbWVGb3JtYXQiLCJEYXRlVGltZUZvcm1hdCIsImdldFBsdXJhbFJ1bGVzIiwiUGx1cmFsUnVsZXMiLCJ0aHJvd25FcnJvciIsIm9yaWdpbmFsTWVzc2FnZSIsInNldCIsImZvcm1hdHRlZE1lc3NhZ2UiLCJmb3JtYXQiLCJGT1JNQVRUSU5HX0VSUk9SIiwidHJhbnNsYXRlRm4iLCJyaWNoIiwibWFya3VwIiwicmF3IiwicmVzb2x2ZU5hbWVzcGFjZSIsIm5hbWVzcGFjZVByZWZpeCIsInNsaWNlIiwiU0VDT05EIiwiTUlOVVRFIiwiSE9VUiIsIkRBWSIsIldFRUsiLCJNT05USCIsIlFVQVJURVIiLCJZRUFSIiwiVU5JVF9TRUNPTkRTIiwic2Vjb25kIiwic2Vjb25kcyIsIm1pbnV0ZSIsIm1pbnV0ZXMiLCJob3VyIiwiaG91cnMiLCJkYXkiLCJkYXlzIiwid2VlayIsIndlZWtzIiwibW9udGgiLCJtb250aHMiLCJxdWFydGVyIiwicXVhcnRlcnMiLCJ5ZWFyIiwieWVhcnMiLCJyZXNvbHZlUmVsYXRpdmVUaW1lVW5pdCIsImFic1ZhbHVlIiwiTWF0aCIsImFicyIsImNhbGN1bGF0ZVJlbGF0aXZlVGltZVZhbHVlIiwidW5pdCIsInJvdW5kIiwiY3JlYXRlRm9ybWF0dGVyIiwibm93IiwiZ2xvYmFsTm93IiwiZ2xvYmFsVGltZVpvbmUiLCJyZXNvbHZlRm9ybWF0T3JPcHRpb25zIiwidHlwZUZvcm1hdHMiLCJmb3JtYXRPck9wdGlvbnMiLCJmb3JtYXROYW1lIiwiTUlTU0lOR19GT1JNQVQiLCJnZXRGb3JtYXR0ZWRWYWx1ZSIsImZvcm1hdHRlciIsImdldEZhbGxiYWNrIiwiX29wdGlvbnMiLCJFTlZJUk9OTUVOVF9GQUxMQkFDSyIsIm51bWJlciIsImdldEdsb2JhbE5vdyIsIkRhdGUiLCJleHRyYWN0Tm93RGF0ZSIsIm5vd09yT3B0aW9ucyIsInJlbGF0aXZlVGltZSIsImRhdGVEYXRlIiwibm93RGF0ZSIsImdldFRpbWUiLCJSZWxhdGl2ZVRpbWVGb3JtYXQiLCJudW1lcmljIiwibGlzdCIsInNlcmlhbGl6ZWRWYWx1ZSIsInJpY2hWYWx1ZXMiLCJNYXAiLCJpdGVtIiwic2VyaWFsaXplZEl0ZW0iLCJwdXNoIiwiTGlzdEZvcm1hdCIsImZvcm1hdFRvUGFydHMiLCJtYXAiLCJ0eXBlIiwic2l6ZSIsImpvaW4iLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/development/createFormatter-4ce6f6c8.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/development/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/use-intl/dist/development/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar initializeConfig = __webpack_require__(/*! ./initializeConfig-c503e215.js */ \"(ssr)/./node_modules/use-intl/dist/development/initializeConfig-c503e215.js\");\nvar core = __webpack_require__(/*! ./core.js */ \"(ssr)/./node_modules/use-intl/dist/development/core.js\");\nvar createFormatter = __webpack_require__(/*! ./createFormatter-4ce6f6c8.js */ \"(ssr)/./node_modules/use-intl/dist/development/createFormatter-4ce6f6c8.js\");\nvar _IntlProvider = __webpack_require__(/*! ./_IntlProvider.js */ \"(ssr)/./node_modules/use-intl/dist/development/_IntlProvider.js\");\nvar react = __webpack_require__(/*! ./react.js */ \"(ssr)/./node_modules/use-intl/dist/development/react.js\");\nvar _useLocale = __webpack_require__(/*! ./_useLocale-321e619f.js */ \"(ssr)/./node_modules/use-intl/dist/development/_useLocale-321e619f.js\");\n__webpack_require__(/*! intl-messageformat */ \"(ssr)/./node_modules/intl-messageformat/lib/index.js\");\n__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n__webpack_require__(/*! ./IntlContext-b5cc6be8.js */ \"(ssr)/./node_modules/use-intl/dist/development/IntlContext-b5cc6be8.js\");\nexports.IntlError = initializeConfig.IntlError;\nexports.IntlErrorCode = initializeConfig.IntlErrorCode;\nexports.initializeConfig = initializeConfig.initializeConfig;\nexports.createTranslator = core.createTranslator;\nexports.createFormatter = createFormatter.createFormatter;\nexports.IntlProvider = _IntlProvider.IntlProvider;\nexports.useFormatter = react.useFormatter;\nexports.useMessages = react.useMessages;\nexports.useNow = react.useNow;\nexports.useTimeZone = react.useTimeZone;\nexports.useTranslations = react.useTranslations;\nexports.useLocale = _useLocale.useLocale;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUU3RCxJQUFJQyxtQkFBbUJDLG1CQUFPQSxDQUFDO0FBQy9CLElBQUlDLE9BQU9ELG1CQUFPQSxDQUFDO0FBQ25CLElBQUlFLGtCQUFrQkYsbUJBQU9BLENBQUM7QUFDOUIsSUFBSUcsZ0JBQWdCSCxtQkFBT0EsQ0FBQztBQUM1QixJQUFJSSxRQUFRSixtQkFBT0EsQ0FBQztBQUNwQixJQUFJSyxhQUFhTCxtQkFBT0EsQ0FBQztBQUN6QkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFJUkgsaUJBQWlCLEdBQUdFLGlCQUFpQk8sU0FBUztBQUM5Q1QscUJBQXFCLEdBQUdFLGlCQUFpQlEsYUFBYTtBQUN0RFYsd0JBQXdCLEdBQUdFLGlCQUFpQkEsZ0JBQWdCO0FBQzVERix3QkFBd0IsR0FBR0ksS0FBS08sZ0JBQWdCO0FBQ2hEWCx1QkFBdUIsR0FBR0ssZ0JBQWdCQSxlQUFlO0FBQ3pETCxvQkFBb0IsR0FBR00sY0FBY00sWUFBWTtBQUNqRFosb0JBQW9CLEdBQUdPLE1BQU1NLFlBQVk7QUFDekNiLG1CQUFtQixHQUFHTyxNQUFNTyxXQUFXO0FBQ3ZDZCxjQUFjLEdBQUdPLE1BQU1RLE1BQU07QUFDN0JmLG1CQUFtQixHQUFHTyxNQUFNUyxXQUFXO0FBQ3ZDaEIsdUJBQXVCLEdBQUdPLE1BQU1VLGVBQWU7QUFDL0NqQixpQkFBaUIsR0FBR1EsV0FBV1UsU0FBUyIsInNvdXJjZXMiOlsid2VicGFjazovL3B3YS1zYWFzLy4vbm9kZV9tb2R1bGVzL3VzZS1pbnRsL2Rpc3QvZGV2ZWxvcG1lbnQvaW5kZXguanM/OTVmOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBpbml0aWFsaXplQ29uZmlnID0gcmVxdWlyZSgnLi9pbml0aWFsaXplQ29uZmlnLWM1MDNlMjE1LmpzJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vY29yZS5qcycpO1xudmFyIGNyZWF0ZUZvcm1hdHRlciA9IHJlcXVpcmUoJy4vY3JlYXRlRm9ybWF0dGVyLTRjZTZmNmM4LmpzJyk7XG52YXIgX0ludGxQcm92aWRlciA9IHJlcXVpcmUoJy4vX0ludGxQcm92aWRlci5qcycpO1xudmFyIHJlYWN0ID0gcmVxdWlyZSgnLi9yZWFjdC5qcycpO1xudmFyIF91c2VMb2NhbGUgPSByZXF1aXJlKCcuL191c2VMb2NhbGUtMzIxZTYxOWYuanMnKTtcbnJlcXVpcmUoJ2ludGwtbWVzc2FnZWZvcm1hdCcpO1xucmVxdWlyZSgncmVhY3QnKTtcbnJlcXVpcmUoJy4vSW50bENvbnRleHQtYjVjYzZiZTguanMnKTtcblxuXG5cbmV4cG9ydHMuSW50bEVycm9yID0gaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3I7XG5leHBvcnRzLkludGxFcnJvckNvZGUgPSBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGU7XG5leHBvcnRzLmluaXRpYWxpemVDb25maWcgPSBpbml0aWFsaXplQ29uZmlnLmluaXRpYWxpemVDb25maWc7XG5leHBvcnRzLmNyZWF0ZVRyYW5zbGF0b3IgPSBjb3JlLmNyZWF0ZVRyYW5zbGF0b3I7XG5leHBvcnRzLmNyZWF0ZUZvcm1hdHRlciA9IGNyZWF0ZUZvcm1hdHRlci5jcmVhdGVGb3JtYXR0ZXI7XG5leHBvcnRzLkludGxQcm92aWRlciA9IF9JbnRsUHJvdmlkZXIuSW50bFByb3ZpZGVyO1xuZXhwb3J0cy51c2VGb3JtYXR0ZXIgPSByZWFjdC51c2VGb3JtYXR0ZXI7XG5leHBvcnRzLnVzZU1lc3NhZ2VzID0gcmVhY3QudXNlTWVzc2FnZXM7XG5leHBvcnRzLnVzZU5vdyA9IHJlYWN0LnVzZU5vdztcbmV4cG9ydHMudXNlVGltZVpvbmUgPSByZWFjdC51c2VUaW1lWm9uZTtcbmV4cG9ydHMudXNlVHJhbnNsYXRpb25zID0gcmVhY3QudXNlVHJhbnNsYXRpb25zO1xuZXhwb3J0cy51c2VMb2NhbGUgPSBfdXNlTG9jYWxlLnVzZUxvY2FsZTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImluaXRpYWxpemVDb25maWciLCJyZXF1aXJlIiwiY29yZSIsImNyZWF0ZUZvcm1hdHRlciIsIl9JbnRsUHJvdmlkZXIiLCJyZWFjdCIsIl91c2VMb2NhbGUiLCJJbnRsRXJyb3IiLCJJbnRsRXJyb3JDb2RlIiwiY3JlYXRlVHJhbnNsYXRvciIsIkludGxQcm92aWRlciIsInVzZUZvcm1hdHRlciIsInVzZU1lc3NhZ2VzIiwidXNlTm93IiwidXNlVGltZVpvbmUiLCJ1c2VUcmFuc2xhdGlvbnMiLCJ1c2VMb2NhbGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/development/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/development/initializeConfig-c503e215.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/use-intl/dist/development/initializeConfig-c503e215.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPrimitive(input, hint) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (typeof res !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n}\nlet IntlErrorCode = /*#__PURE__*/ function(IntlErrorCode) {\n    IntlErrorCode[\"MISSING_MESSAGE\"] = \"MISSING_MESSAGE\";\n    IntlErrorCode[\"MISSING_FORMAT\"] = \"MISSING_FORMAT\";\n    IntlErrorCode[\"ENVIRONMENT_FALLBACK\"] = \"ENVIRONMENT_FALLBACK\";\n    IntlErrorCode[\"INSUFFICIENT_PATH\"] = \"INSUFFICIENT_PATH\";\n    IntlErrorCode[\"INVALID_MESSAGE\"] = \"INVALID_MESSAGE\";\n    IntlErrorCode[\"INVALID_KEY\"] = \"INVALID_KEY\";\n    IntlErrorCode[\"FORMATTING_ERROR\"] = \"FORMATTING_ERROR\";\n    return IntlErrorCode;\n}({});\nclass IntlError extends Error {\n    constructor(code, originalMessage){\n        let message = code;\n        if (originalMessage) {\n            message += \": \" + originalMessage;\n        }\n        super(message);\n        _defineProperty(this, \"code\", void 0);\n        _defineProperty(this, \"originalMessage\", void 0);\n        this.code = code;\n        if (originalMessage) {\n            this.originalMessage = originalMessage;\n        }\n    }\n}\nfunction joinPath() {\n    for(var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++){\n        parts[_key] = arguments[_key];\n    }\n    return parts.filter(Boolean).join(\".\");\n}\n/**\n * Contains defaults that are used for all entry points into the core.\n * See also `InitializedIntlConfiguration`.\n */ function defaultGetMessageFallback(props) {\n    return joinPath(props.namespace, props.key);\n}\nfunction defaultOnError(error) {\n    console.error(error);\n}\nfunction validateMessagesSegment(messages, invalidKeyLabels, parentPath) {\n    Object.entries(messages).forEach((_ref)=>{\n        let [key, messageOrMessages] = _ref;\n        if (key.includes(\".\")) {\n            let keyLabel = key;\n            if (parentPath) keyLabel += \" (at \".concat(parentPath, \")\");\n            invalidKeyLabels.push(keyLabel);\n        }\n        if (messageOrMessages != null && typeof messageOrMessages === \"object\") {\n            validateMessagesSegment(messageOrMessages, invalidKeyLabels, joinPath(parentPath, key));\n        }\n    });\n}\nfunction validateMessages(messages, onError) {\n    const invalidKeyLabels = [];\n    validateMessagesSegment(messages, invalidKeyLabels);\n    if (invalidKeyLabels.length > 0) {\n        onError(new IntlError(IntlErrorCode.INVALID_KEY, 'Namespace keys can not contain the character \".\" as this is used to express nesting. Please remove it or replace it with another character.\\n\\nInvalid '.concat(invalidKeyLabels.length === 1 ? \"key\" : \"keys\", \": \").concat(invalidKeyLabels.join(\", \"), '\\n\\nIf you\\'re migrating from a flat structure, you can convert your messages as follows:\\n\\nimport {set} from \"lodash\";\\n\\nconst input = {\\n  \"one.one\": \"1.1\",\\n  \"one.two\": \"1.2\",\\n  \"two.one.one\": \"2.1.1\"\\n};\\n\\nconst output = Object.entries(input).reduce(\\n  (acc, [key, value]) => set(acc, key, value),\\n  {}\\n);\\n\\n// Output:\\n//\\n// {\\n//   \"one\": {\\n//     \"one\": \"1.1\",\\n//     \"two\": \"1.2\"\\n//   },\\n//   \"two\": {\\n//     \"one\": {\\n//       \"one\": \"2.1.1\"\\n//     }\\n//   }\\n// }\\n')));\n    }\n}\n/**\n * Enhances the incoming props with defaults.\n */ function initializeConfig(_ref) {\n    let { getMessageFallback, messages, onError, ...rest } = _ref;\n    const finalOnError = onError || defaultOnError;\n    const finalGetMessageFallback = getMessageFallback || defaultGetMessageFallback;\n    {\n        if (messages) {\n            validateMessages(messages, finalOnError);\n        }\n    }\n    return {\n        ...rest,\n        messages,\n        onError: finalOnError,\n        getMessageFallback: finalGetMessageFallback\n    };\n}\nexports.IntlError = IntlError;\nexports.IntlErrorCode = IntlErrorCode;\nexports.defaultGetMessageFallback = defaultGetMessageFallback;\nexports.defaultOnError = defaultOnError;\nexports.initializeConfig = initializeConfig;\nexports.joinPath = joinPath;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9pbml0aWFsaXplQ29uZmlnLWM1MDNlMjE1LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsU0FBU0EsZ0JBQWdCQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsS0FBSztJQUN0Q0QsTUFBTUUsZUFBZUY7SUFDckIsSUFBSUEsT0FBT0QsS0FBSztRQUNkSSxPQUFPQyxjQUFjLENBQUNMLEtBQUtDLEtBQUs7WUFDOUJDLE9BQU9BO1lBQ1BJLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1FBQ1o7SUFDRixPQUFPO1FBQ0xSLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHQztJQUNiO0lBQ0EsT0FBT0Y7QUFDVDtBQUNBLFNBQVNTLGFBQWFDLEtBQUssRUFBRUMsSUFBSTtJQUMvQixJQUFJLE9BQU9ELFVBQVUsWUFBWUEsVUFBVSxNQUFNLE9BQU9BO0lBQ3hELElBQUlFLE9BQU9GLEtBQUssQ0FBQ0csT0FBT0MsV0FBVyxDQUFDO0lBQ3BDLElBQUlGLFNBQVNHLFdBQVc7UUFDdEIsSUFBSUMsTUFBTUosS0FBS0ssSUFBSSxDQUFDUCxPQUFPQyxRQUFRO1FBQ25DLElBQUksT0FBT0ssUUFBUSxVQUFVLE9BQU9BO1FBQ3BDLE1BQU0sSUFBSUUsVUFBVTtJQUN0QjtJQUNBLE9BQU8sQ0FBQ1AsU0FBUyxXQUFXUSxTQUFTQyxNQUFLLEVBQUdWO0FBQy9DO0FBQ0EsU0FBU1AsZUFBZWtCLEdBQUc7SUFDekIsSUFBSXBCLE1BQU1RLGFBQWFZLEtBQUs7SUFDNUIsT0FBTyxPQUFPcEIsUUFBUSxXQUFXQSxNQUFNa0IsT0FBT2xCO0FBQ2hEO0FBRUEsSUFBSXFCLGdCQUFnQixXQUFXLEdBQUUsU0FBVUEsYUFBYTtJQUN0REEsYUFBYSxDQUFDLGtCQUFrQixHQUFHO0lBQ25DQSxhQUFhLENBQUMsaUJBQWlCLEdBQUc7SUFDbENBLGFBQWEsQ0FBQyx1QkFBdUIsR0FBRztJQUN4Q0EsYUFBYSxDQUFDLG9CQUFv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dXJjZXMiOlsid2VicGFjazovL3B3YS1zYWFzLy4vbm9kZV9tb2R1bGVzL3VzZS1pbnRsL2Rpc3QvZGV2ZWxvcG1lbnQvaW5pdGlhbGl6ZUNvbmZpZy1jNTAzZTIxNS5qcz9hYzQ4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpO1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDtcbiAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKHR5cGVvZiByZXMgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpO1xufVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7XG4gIHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTtcbn1cblxubGV0IEludGxFcnJvckNvZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKEludGxFcnJvckNvZGUpIHtcbiAgSW50bEVycm9yQ29kZVtcIk1JU1NJTkdfTUVTU0FHRVwiXSA9IFwiTUlTU0lOR19NRVNTQUdFXCI7XG4gIEludGxFcnJvckNvZGVbXCJNSVNTSU5HX0ZPUk1BVFwiXSA9IFwiTUlTU0lOR19GT1JNQVRcIjtcbiAgSW50bEVycm9yQ29kZVtcIkVOVklST05NRU5UX0ZBTExCQUNLXCJdID0gXCJFTlZJUk9OTUVOVF9GQUxMQkFDS1wiO1xuICBJbnRsRXJyb3JDb2RlW1wiSU5TVUZGSUNJRU5UX1BBVEhcIl0gPSBcIklOU1VGRklDSUVOVF9QQVRIXCI7XG4gIEludGxFcnJvckNvZGVbXCJJTlZBTElEX01FU1NBR0VcIl0gPSBcIklOVkFMSURfTUVTU0FHRVwiO1xuICBJbnRsRXJyb3JDb2RlW1wiSU5WQUxJRF9LRVlcIl0gPSBcIklOVkFMSURfS0VZXCI7XG4gIEludGxFcnJvckNvZGVbXCJGT1JNQVRUSU5HX0VSUk9SXCJdID0gXCJGT1JNQVRUSU5HX0VSUk9SXCI7XG4gIHJldHVybiBJbnRsRXJyb3JDb2RlO1xufSh7fSk7XG5jbGFzcyBJbnRsRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNvZGUsIG9yaWdpbmFsTWVzc2FnZSkge1xuICAgIGxldCBtZXNzYWdlID0gY29kZTtcbiAgICBpZiAob3JpZ2luYWxNZXNzYWdlKSB7XG4gICAgICBtZXNzYWdlICs9ICc6ICcgKyBvcmlnaW5hbE1lc3NhZ2U7XG4gICAgfVxuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvcmlnaW5hbE1lc3NhZ2VcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIGlmIChvcmlnaW5hbE1lc3NhZ2UpIHtcbiAgICAgIHRoaXMub3JpZ2luYWxNZXNzYWdlID0gb3JpZ2luYWxNZXNzYWdlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBqb2luUGF0aCgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBhcnRzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHBhcnRzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIHJldHVybiBwYXJ0cy5maWx0ZXIoQm9vbGVhbikuam9pbignLicpO1xufVxuXG4vKipcbiAqIENvbnRhaW5zIGRlZmF1bHRzIHRoYXQgYXJlIHVzZWQgZm9yIGFsbCBlbnRyeSBwb2ludHMgaW50byB0aGUgY29yZS5cbiAqIFNlZSBhbHNvIGBJbml0aWFsaXplZEludGxDb25maWd1cmF0aW9uYC5cbiAqL1xuXG5mdW5jdGlvbiBkZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrKHByb3BzKSB7XG4gIHJldHVybiBqb2luUGF0aChwcm9wcy5uYW1lc3BhY2UsIHByb3BzLmtleSk7XG59XG5mdW5jdGlvbiBkZWZhdWx0T25FcnJvcihlcnJvcikge1xuICBjb25zb2xlLmVycm9yKGVycm9yKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVNZXNzYWdlc1NlZ21lbnQobWVzc2FnZXMsIGludmFsaWRLZXlMYWJlbHMsIHBhcmVudFBhdGgpIHtcbiAgT2JqZWN0LmVudHJpZXMobWVzc2FnZXMpLmZvckVhY2goX3JlZiA9PiB7XG4gICAgbGV0IFtrZXksIG1lc3NhZ2VPck1lc3NhZ2VzXSA9IF9yZWY7XG4gICAgaWYgKGtleS5pbmNsdWRlcygnLicpKSB7XG4gICAgICBsZXQga2V5TGFiZWwgPSBrZXk7XG4gICAgICBpZiAocGFyZW50UGF0aCkga2V5TGFiZWwgKz0gXCIgKGF0IFwiLmNvbmNhdChwYXJlbnRQYXRoLCBcIilcIik7XG4gICAgICBpbnZhbGlkS2V5TGFiZWxzLnB1c2goa2V5TGFiZWwpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZU9yTWVzc2FnZXMgIT0gbnVsbCAmJiB0eXBlb2YgbWVzc2FnZU9yTWVzc2FnZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YWxpZGF0ZU1lc3NhZ2VzU2VnbWVudChtZXNzYWdlT3JNZXNzYWdlcywgaW52YWxpZEtleUxhYmVscywgam9pblBhdGgocGFyZW50UGF0aCwga2V5KSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTWVzc2FnZXMobWVzc2FnZXMsIG9uRXJyb3IpIHtcbiAgY29uc3QgaW52YWxpZEtleUxhYmVscyA9IFtdO1xuICB2YWxpZGF0ZU1lc3NhZ2VzU2VnbWVudChtZXNzYWdlcywgaW52YWxpZEtleUxhYmVscyk7XG4gIGlmIChpbnZhbGlkS2V5TGFiZWxzLmxlbmd0aCA+IDApIHtcbiAgICBvbkVycm9yKG5ldyBJbnRsRXJyb3IoSW50bEVycm9yQ29kZS5JTlZBTElEX0tFWSwgXCJOYW1lc3BhY2Uga2V5cyBjYW4gbm90IGNvbnRhaW4gdGhlIGNoYXJhY3RlciBcXFwiLlxcXCIgYXMgdGhpcyBpcyB1c2VkIHRvIGV4cHJlc3MgbmVzdGluZy4gUGxlYXNlIHJlbW92ZSBpdCBvciByZXBsYWNlIGl0IHdpdGggYW5vdGhlciBjaGFyYWN0ZXIuXFxuXFxuSW52YWxpZCBcIi5jb25jYXQoaW52YWxpZEtleUxhYmVscy5sZW5ndGggPT09IDEgPyAna2V5JyA6ICdrZXlzJywgXCI6IFwiKS5jb25jYXQoaW52YWxpZEtleUxhYmVscy5qb2luKCcsICcpLCBcIlxcblxcbklmIHlvdSdyZSBtaWdyYXRpbmcgZnJvbSBhIGZsYXQgc3RydWN0dXJlLCB5b3UgY2FuIGNvbnZlcnQgeW91ciBtZXNzYWdlcyBhcyBmb2xsb3dzOlxcblxcbmltcG9ydCB7c2V0fSBmcm9tIFxcXCJsb2Rhc2hcXFwiO1xcblxcbmNvbnN0IGlucHV0ID0ge1xcbiAgXFxcIm9uZS5vbmVcXFwiOiBcXFwiMS4xXFxcIixcXG4gIFxcXCJvbmUudHdvXFxcIjogXFxcIjEuMlxcXCIsXFxuICBcXFwidHdvLm9uZS5vbmVcXFwiOiBcXFwiMi4xLjFcXFwiXFxufTtcXG5cXG5jb25zdCBvdXRwdXQgPSBPYmplY3QuZW50cmllcyhpbnB1dCkucmVkdWNlKFxcbiAgKGFjYywgW2tleSwgdmFsdWVdKSA9PiBzZXQoYWNjLCBrZXksIHZhbHVlKSxcXG4gIHt9XFxuKTtcXG5cXG4vLyBPdXRwdXQ6XFxuLy9cXG4vLyB7XFxuLy8gICBcXFwib25lXFxcIjoge1xcbi8vICAgICBcXFwib25lXFxcIjogXFxcIjEuMVxcXCIsXFxuLy8gICAgIFxcXCJ0d29cXFwiOiBcXFwiMS4yXFxcIlxcbi8vICAgfSxcXG4vLyAgIFxcXCJ0d29cXFwiOiB7XFxuLy8gICAgIFxcXCJvbmVcXFwiOiB7XFxuLy8gICAgICAgXFxcIm9uZVxcXCI6IFxcXCIyLjEuMVxcXCJcXG4vLyAgICAgfVxcbi8vICAgfVxcbi8vIH1cXG5cIikgKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbmhhbmNlcyB0aGUgaW5jb21pbmcgcHJvcHMgd2l0aCBkZWZhdWx0cy5cbiAqL1xuZnVuY3Rpb24gaW5pdGlhbGl6ZUNvbmZpZyhfcmVmKSB7XG4gIGxldCB7XG4gICAgZ2V0TWVzc2FnZUZhbGxiYWNrLFxuICAgIG1lc3NhZ2VzLFxuICAgIG9uRXJyb3IsXG4gICAgLi4ucmVzdFxuICB9ID0gX3JlZjtcbiAgY29uc3QgZmluYWxPbkVycm9yID0gb25FcnJvciB8fCBkZWZhdWx0T25FcnJvcjtcbiAgY29uc3QgZmluYWxHZXRNZXNzYWdlRmFsbGJhY2sgPSBnZXRNZXNzYWdlRmFsbGJhY2sgfHwgZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjaztcbiAge1xuICAgIGlmIChtZXNzYWdlcykge1xuICAgICAgdmFsaWRhdGVNZXNzYWdlcyhtZXNzYWdlcywgZmluYWxPbkVycm9yKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5yZXN0LFxuICAgIG1lc3NhZ2VzLFxuICAgIG9uRXJyb3I6IGZpbmFsT25FcnJvcixcbiAgICBnZXRNZXNzYWdlRmFsbGJhY2s6IGZpbmFsR2V0TWVzc2FnZUZhbGxiYWNrXG4gIH07XG59XG5cbmV4cG9ydHMuSW50bEVycm9yID0gSW50bEVycm9yO1xuZXhwb3J0cy5JbnRsRXJyb3JDb2RlID0gSW50bEVycm9yQ29kZTtcbmV4cG9ydHMuZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjayA9IGRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2s7XG5leHBvcnRzLmRlZmF1bHRPbkVycm9yID0gZGVmYXVsdE9uRXJyb3I7XG5leHBvcnRzLmluaXRpYWxpemVDb25maWcgPSBpbml0aWFsaXplQ29uZmlnO1xuZXhwb3J0cy5qb2luUGF0aCA9IGpvaW5QYXRoO1xuIl0sIm5hbWVzIjpbIl9kZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsInZhbHVlIiwiX3RvUHJvcGVydHlLZXkiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1ByaW1pdGl2ZSIsImlucHV0IiwiaGludCIsInByaW0iLCJTeW1ib2wiLCJ0b1ByaW1pdGl2ZSIsInVuZGVmaW5lZCIsInJlcyIsImNhbGwiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiLCJhcmciLCJJbnRsRXJyb3JDb2RlIiwiSW50bEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsImNvZGUiLCJvcmlnaW5hbE1lc3NhZ2UiLCJtZXNzYWdlIiwiam9pblBhdGgiLCJfbGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwicGFydHMiLCJBcnJheSIsIl9rZXkiLCJmaWx0ZXIiLCJCb29sZWFuIiwiam9pbiIsImRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2siLCJwcm9wcyIsIm5hbWVzcGFjZSIsImRlZmF1bHRPbkVycm9yIiwiZXJyb3IiLCJjb25zb2xlIiwidmFsaWRhdGVNZXNzYWdlc1NlZ21lbnQiLCJtZXNzYWdlcyIsImludmFsaWRLZXlMYWJlbHMiLCJwYXJlbnRQYXRoIiwiZW50cmllcyIsImZvckVhY2giLCJfcmVmIiwibWVzc2FnZU9yTWVzc2FnZXMiLCJpbmNsdWRlcyIsImtleUxhYmVsIiwiY29uY2F0IiwicHVzaCIsInZhbGlkYXRlTWVzc2FnZXMiLCJvbkVycm9yIiwiSU5WQUxJRF9LRVkiLCJpbml0aWFsaXplQ29uZmlnIiwiZ2V0TWVzc2FnZUZhbGxiYWNrIiwicmVzdCIsImZpbmFsT25FcnJvciIsImZpbmFsR2V0TWVzc2FnZUZhbGxiYWNrIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/development/initializeConfig-c503e215.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/development/react.js":
/*!*********************************************************!*\
  !*** ./node_modules/use-intl/dist/development/react.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _IntlProvider = __webpack_require__(/*! ./_IntlProvider.js */ \"(ssr)/./node_modules/use-intl/dist/development/_IntlProvider.js\");\nvar _useLocale = __webpack_require__(/*! ./_useLocale-321e619f.js */ \"(ssr)/./node_modules/use-intl/dist/development/_useLocale-321e619f.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar createFormatter = __webpack_require__(/*! ./createFormatter-4ce6f6c8.js */ \"(ssr)/./node_modules/use-intl/dist/development/createFormatter-4ce6f6c8.js\");\nvar initializeConfig = __webpack_require__(/*! ./initializeConfig-c503e215.js */ \"(ssr)/./node_modules/use-intl/dist/development/initializeConfig-c503e215.js\");\n__webpack_require__(/*! ./IntlContext-b5cc6be8.js */ \"(ssr)/./node_modules/use-intl/dist/development/IntlContext-b5cc6be8.js\");\n__webpack_require__(/*! intl-messageformat */ \"(ssr)/./node_modules/intl-messageformat/lib/index.js\");\nlet hasWarnedForMissingTimezone = false;\nconst isServer = \"undefined\" === \"undefined\";\nfunction useTranslationsImpl(allMessages, namespace, namespacePrefix) {\n    const { defaultTranslationValues, formats: globalFormats, getMessageFallback, locale, messageFormatCache, onError, timeZone } = _useLocale.useIntlContext();\n    // The `namespacePrefix` is part of the type system.\n    // See the comment in the hook invocation.\n    allMessages = allMessages[namespacePrefix];\n    namespace = createFormatter.resolveNamespace(namespace, namespacePrefix);\n    if (!timeZone && !hasWarnedForMissingTimezone && isServer) {\n        hasWarnedForMissingTimezone = true;\n        onError(new initializeConfig.IntlError(initializeConfig.IntlErrorCode.ENVIRONMENT_FALLBACK, \"There is no `timeZone` configured, this can lead to markup mismatches caused by environment differences. Consider adding a global default: https://next-intl-docs.vercel.app/docs/configuration#time-zone\"));\n    }\n    const translate = React.useMemo(()=>createFormatter.createBaseTranslator({\n            messageFormatCache,\n            getMessageFallback,\n            messages: allMessages,\n            defaultTranslationValues,\n            namespace,\n            onError,\n            formats: globalFormats,\n            locale,\n            timeZone\n        }), [\n        messageFormatCache,\n        getMessageFallback,\n        allMessages,\n        namespace,\n        onError,\n        defaultTranslationValues,\n        globalFormats,\n        locale,\n        timeZone\n    ]);\n    return translate;\n}\n/**\n * Translates messages from the given namespace by using the ICU syntax.\n * See https://formatjs.io/docs/core-concepts/icu-syntax.\n *\n * If no namespace is provided, all available messages are returned.\n * The namespace can also indicate nesting by using a dot\n * (e.g. `namespace.Component`).\n */ function useTranslations(namespace) {\n    const context = _useLocale.useIntlContext();\n    const messages = context.messages;\n    // We have to wrap the actual hook so the type inference for the optional\n    // namespace works correctly. See https://stackoverflow.com/a/71529575/343045\n    // The prefix (\"!\") is arbitrary.\n    return useTranslationsImpl({\n        \"!\": messages\n    }, // @ts-expect-error\n    namespace ? \"!.\".concat(namespace) : \"!\", \"!\");\n}\nfunction getNow() {\n    return new Date();\n}\n/**\n * Reading the current date via `new Date()` in components should be avoided, as\n * it causes components to be impure and can lead to flaky tests. Instead, this\n * hook can be used.\n *\n * By default, it returns the time when the component mounts. If `updateInterval`\n * is specified, the value will be updated based on the interval.\n *\n * You can however also return a static value from this hook, if you\n * configure the `now` parameter on the context provider. Note however,\n * that if `updateInterval` is configured in this case, the component\n * will initialize with the global value, but will afterwards update\n * continuously based on the interval.\n *\n * For unit tests, this can be mocked to a constant value. For end-to-end\n * testing, an environment parameter can be passed to the `now` parameter\n * of the provider to mock this to a static value.\n */ function useNow(options) {\n    const updateInterval = options === null || options === void 0 ? void 0 : options.updateInterval;\n    const { now: globalNow } = _useLocale.useIntlContext();\n    const [now, setNow] = React.useState(globalNow || getNow());\n    React.useEffect(()=>{\n        if (!updateInterval) return;\n        const intervalId = setInterval(()=>{\n            setNow(getNow());\n        }, updateInterval);\n        return ()=>{\n            clearInterval(intervalId);\n        };\n    }, [\n        globalNow,\n        updateInterval\n    ]);\n    return now;\n}\nfunction useTimeZone() {\n    return _useLocale.useIntlContext().timeZone;\n}\nfunction useMessages() {\n    const context = _useLocale.useIntlContext();\n    if (!context.messages) {\n        throw new Error(\"No messages found. Have you configured them correctly? See https://next-intl-docs.vercel.app/docs/configuration#messages\");\n    }\n    return context.messages;\n}\nfunction useFormatter() {\n    const { formats, locale, now: globalNow, onError, timeZone } = _useLocale.useIntlContext();\n    return React.useMemo(()=>createFormatter.createFormatter({\n            formats,\n            locale,\n            now: globalNow,\n            onError,\n            timeZone\n        }), [\n        formats,\n        globalNow,\n        locale,\n        onError,\n        timeZone\n    ]);\n}\nexports.IntlProvider = _IntlProvider.IntlProvider;\nexports.useLocale = _useLocale.useLocale;\nexports.useFormatter = useFormatter;\nexports.useMessages = useMessages;\nexports.useNow = useNow;\nexports.useTimeZone = useTimeZone;\nexports.useTranslations = useTranslations;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9yZWFjdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUU3RCxJQUFJQyxnQkFBZ0JDLG1CQUFPQSxDQUFDO0FBQzVCLElBQUlDLGFBQWFELG1CQUFPQSxDQUFDO0FBQ3pCLElBQUlFLFFBQVFGLG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlHLGtCQUFrQkgsbUJBQU9BLENBQUM7QUFDOUIsSUFBSUksbUJBQW1CSixtQkFBT0EsQ0FBQztBQUMvQkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFFUixJQUFJSyw4QkFBOEI7QUFDbEMsTUFBTUMsV0FBVyxnQkFBa0I7QUFDbkMsU0FBU0Msb0JBQW9CQyxXQUFXLEVBQUVDLFNBQVMsRUFBRUMsZUFBZTtJQUNsRSxNQUFNLEVBQ0pDLHdCQUF3QixFQUN4QkMsU0FBU0MsYUFBYSxFQUN0QkMsa0JBQWtCLEVBQ2xCQyxNQUFNLEVBQ05DLGtCQUFrQixFQUNsQkMsT0FBTyxFQUNQQyxRQUFRLEVBQ1QsR0FBR2pCLFdBQVdrQixjQUFjO0lBRTdCLG9EQUFvRDtJQUNwRCwwQ0FBMEM7SUFDMUNYLGNBQWNBLFdBQVcsQ0FBQ0UsZ0JBQWdCO0lBQzFDRCxZQUFZTixnQkFBZ0JpQixnQkFBZ0IsQ0FBQ1gsV0FBV0M7SUFDeEQsSUFBSSxDQUFDUSxZQUFZLENBQUNiLCtCQUErQkMsVUFBVTtRQUN6REQsOEJBQThCO1FBQzlCWSxRQUFRLElBQUliLGlCQUFpQmlCLFNBQVMsQ0FBQ2pCLGlCQUFpQmtCLGFBQWEsQ0FBQ0Msb0JBQW9CLEVBQUU7SUFDOUY7SUFDQSxNQUFNQyxZQUFZdEIsTUFBTXVCLE9BQU8sQ0FBQyxJQUFNdEIsZ0JBQWdCdUIsb0JBQW9CLENBQUM7WUFDekVWO1lBQ0FGO1lBQ0FhLFVBQVVuQjtZQUNWRztZQUNBRjtZQUNBUTtZQUNBTCxTQUFTQztZQUNURTtZQUNBRztRQUNGLElBQUk7UUFBQ0Y7UUFBb0JGO1FBQW9CTjtRQUFhQztRQUFXUTtRQUFTTjtRQUEwQkU7UUFBZUU7UUFBUUc7S0FBUztJQUN4SSxPQUFPTTtBQUNUO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNJLGdCQUFnQm5CLFNBQVM7SUFDaEMsTUFBTW9CLFVBQVU1QixXQUFXa0IsY0FBYztJQUN6QyxNQUFNUSxXQUFXRSxRQUFRRixRQUFRO0lBRWpDLHlFQUF5RTtJQUN6RSw2RUFBNkU7SUFDN0UsaUNBQWlDO0lBQ2pDLE9BQU9wQixvQkFBb0I7UUFDekIsS0FBS29CO0lBQ1AsR0FDQSxtQkFBbUI7SUFDbkJsQixZQUFZLEtBQUtxQixNQUFNLENBQUNyQixhQUFhLEtBQUs7QUFDNUM7QUFFQSxTQUFTc0I7SUFDUCxPQUFPLElBQUlDO0FBQ2I7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FDRCxTQUFTQyxPQUFPQyxPQUFPO0lBQ3JCLE1BQU1DLGlCQUFpQkQsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFDLGNBQWM7SUFDL0YsTUFBTSxFQUNKQyxLQUFLQyxTQUFTLEVBQ2YsR0FBR3BDLFdBQVdrQixjQUFjO0lBQzdCLE1BQU0sQ0FBQ2lCLEtBQUtFLE9BQU8sR0FBR3BDLE1BQU1xQyxRQUFRLENBQUNGLGFBQWFOO0lBQ2xEN0IsTUFBTXNDLFNBQVMsQ0FBQztRQUNkLElBQUksQ0FBQ0wsZ0JBQWdCO1FBQ3JCLE1BQU1NLGFBQWFDLFlBQVk7WUFDN0JKLE9BQU9QO1FBQ1QsR0FBR0k7UUFDSCxPQUFPO1lBQ0xRLGNBQWNGO1FBQ2hCO0lBQ0YsR0FBRztRQUFDSjtRQUFXRjtLQUFlO0lBQzlCLE9BQU9DO0FBQ1Q7QUFFQSxTQUFTUTtJQUNQLE9BQU8zQyxXQUFXa0IsY0FBYyxHQUFHRCxRQUFRO0FBQzdDO0FBRUEsU0FBUzJCO0lBQ1AsTUFBTWhCLFVBQVU1QixXQUFXa0IsY0FBYztJQUN6QyxJQUFJLENBQUNVLFFBQVFGLFFBQVEsRUFBRTtRQUNyQixNQUFNLElBQUltQixNQUFNO0lBQ2xCO0lBQ0EsT0FBT2pCLFFBQVFGLFFBQVE7QUFDekI7QUFFQSxTQUFTb0I7SUFDUCxNQUFNLEVBQ0puQyxPQUFPLEVBQ1BHLE1BQU0sRUFDTnFCLEtBQUtDLFNBQVMsRUFDZHBCLE9BQU8sRUFDUEMsUUFBUSxFQUNULEdBQUdqQixXQUFXa0IsY0FBYztJQUM3QixPQUFPakIsTUFBTXVCLE9BQU8sQ0FBQyxJQUFNdEIsZ0JBQWdCQSxlQUFlLENBQUM7WUFDekRTO1lBQ0FHO1lBQ0FxQixLQUFLQztZQUNMcEI7WUFDQUM7UUFDRixJQUFJO1FBQUNOO1FBQVN5QjtRQUFXdEI7UUFBUUU7UUFBU0M7S0FBUztBQUNyRDtBQUVBckIsb0JBQW9CLEdBQUdFLGNBQWNpRCxZQUFZO0FBQ2pEbkQsaUJBQWlCLEdBQUdJLFdBQVdnRCxTQUFTO0FBQ3hDcEQsb0JBQW9CLEdBQUdrRDtBQUN2QmxELG1CQUFtQixHQUFHZ0Q7QUFDdEJoRCxjQUFjLEdBQUdvQztBQUNqQnBDLG1CQUFtQixHQUFHK0M7QUFDdEIvQyx1QkFBdUIsR0FBRytCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHdhLXNhYXMvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9yZWFjdC5qcz8yMTc1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIF9JbnRsUHJvdmlkZXIgPSByZXF1aXJlKCcuL19JbnRsUHJvdmlkZXIuanMnKTtcbnZhciBfdXNlTG9jYWxlID0gcmVxdWlyZSgnLi9fdXNlTG9jYWxlLTMyMWU2MTlmLmpzJyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGNyZWF0ZUZvcm1hdHRlciA9IHJlcXVpcmUoJy4vY3JlYXRlRm9ybWF0dGVyLTRjZTZmNmM4LmpzJyk7XG52YXIgaW5pdGlhbGl6ZUNvbmZpZyA9IHJlcXVpcmUoJy4vaW5pdGlhbGl6ZUNvbmZpZy1jNTAzZTIxNS5qcycpO1xucmVxdWlyZSgnLi9JbnRsQ29udGV4dC1iNWNjNmJlOC5qcycpO1xucmVxdWlyZSgnaW50bC1tZXNzYWdlZm9ybWF0Jyk7XG5cbmxldCBoYXNXYXJuZWRGb3JNaXNzaW5nVGltZXpvbmUgPSBmYWxzZTtcbmNvbnN0IGlzU2VydmVyID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCc7XG5mdW5jdGlvbiB1c2VUcmFuc2xhdGlvbnNJbXBsKGFsbE1lc3NhZ2VzLCBuYW1lc3BhY2UsIG5hbWVzcGFjZVByZWZpeCkge1xuICBjb25zdCB7XG4gICAgZGVmYXVsdFRyYW5zbGF0aW9uVmFsdWVzLFxuICAgIGZvcm1hdHM6IGdsb2JhbEZvcm1hdHMsXG4gICAgZ2V0TWVzc2FnZUZhbGxiYWNrLFxuICAgIGxvY2FsZSxcbiAgICBtZXNzYWdlRm9ybWF0Q2FjaGUsXG4gICAgb25FcnJvcixcbiAgICB0aW1lWm9uZVxuICB9ID0gX3VzZUxvY2FsZS51c2VJbnRsQ29udGV4dCgpO1xuXG4gIC8vIFRoZSBgbmFtZXNwYWNlUHJlZml4YCBpcyBwYXJ0IG9mIHRoZSB0eXBlIHN5c3RlbS5cbiAgLy8gU2VlIHRoZSBjb21tZW50IGluIHRoZSBob29rIGludm9jYXRpb24uXG4gIGFsbE1lc3NhZ2VzID0gYWxsTWVzc2FnZXNbbmFtZXNwYWNlUHJlZml4XTtcbiAgbmFtZXNwYWNlID0gY3JlYXRlRm9ybWF0dGVyLnJlc29sdmVOYW1lc3BhY2UobmFtZXNwYWNlLCBuYW1lc3BhY2VQcmVmaXgpO1xuICBpZiAoIXRpbWVab25lICYmICFoYXNXYXJuZWRGb3JNaXNzaW5nVGltZXpvbmUgJiYgaXNTZXJ2ZXIpIHtcbiAgICBoYXNXYXJuZWRGb3JNaXNzaW5nVGltZXpvbmUgPSB0cnVlO1xuICAgIG9uRXJyb3IobmV3IGluaXRpYWxpemVDb25maWcuSW50bEVycm9yKGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZS5FTlZJUk9OTUVOVF9GQUxMQkFDSywgXCJUaGVyZSBpcyBubyBgdGltZVpvbmVgIGNvbmZpZ3VyZWQsIHRoaXMgY2FuIGxlYWQgdG8gbWFya3VwIG1pc21hdGNoZXMgY2F1c2VkIGJ5IGVudmlyb25tZW50IGRpZmZlcmVuY2VzLiBDb25zaWRlciBhZGRpbmcgYSBnbG9iYWwgZGVmYXVsdDogaHR0cHM6Ly9uZXh0LWludGwtZG9jcy52ZXJjZWwuYXBwL2RvY3MvY29uZmlndXJhdGlvbiN0aW1lLXpvbmVcIiApKTtcbiAgfVxuICBjb25zdCB0cmFuc2xhdGUgPSBSZWFjdC51c2VNZW1vKCgpID0+IGNyZWF0ZUZvcm1hdHRlci5jcmVhdGVCYXNlVHJhbnNsYXRvcih7XG4gICAgbWVzc2FnZUZvcm1hdENhY2hlLFxuICAgIGdldE1lc3NhZ2VGYWxsYmFjayxcbiAgICBtZXNzYWdlczogYWxsTWVzc2FnZXMsXG4gICAgZGVmYXVsdFRyYW5zbGF0aW9uVmFsdWVzLFxuICAgIG5hbWVzcGFjZSxcbiAgICBvbkVycm9yLFxuICAgIGZvcm1hdHM6IGdsb2JhbEZvcm1hdHMsXG4gICAgbG9jYWxlLFxuICAgIHRpbWVab25lXG4gIH0pLCBbbWVzc2FnZUZvcm1hdENhY2hlLCBnZXRNZXNzYWdlRmFsbGJhY2ssIGFsbE1lc3NhZ2VzLCBuYW1lc3BhY2UsIG9uRXJyb3IsIGRlZmF1bHRUcmFuc2xhdGlvblZhbHVlcywgZ2xvYmFsRm9ybWF0cywgbG9jYWxlLCB0aW1lWm9uZV0pO1xuICByZXR1cm4gdHJhbnNsYXRlO1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZXMgbWVzc2FnZXMgZnJvbSB0aGUgZ2l2ZW4gbmFtZXNwYWNlIGJ5IHVzaW5nIHRoZSBJQ1Ugc3ludGF4LlxuICogU2VlIGh0dHBzOi8vZm9ybWF0anMuaW8vZG9jcy9jb3JlLWNvbmNlcHRzL2ljdS1zeW50YXguXG4gKlxuICogSWYgbm8gbmFtZXNwYWNlIGlzIHByb3ZpZGVkLCBhbGwgYXZhaWxhYmxlIG1lc3NhZ2VzIGFyZSByZXR1cm5lZC5cbiAqIFRoZSBuYW1lc3BhY2UgY2FuIGFsc28gaW5kaWNhdGUgbmVzdGluZyBieSB1c2luZyBhIGRvdFxuICogKGUuZy4gYG5hbWVzcGFjZS5Db21wb25lbnRgKS5cbiAqL1xuZnVuY3Rpb24gdXNlVHJhbnNsYXRpb25zKG5hbWVzcGFjZSkge1xuICBjb25zdCBjb250ZXh0ID0gX3VzZUxvY2FsZS51c2VJbnRsQ29udGV4dCgpO1xuICBjb25zdCBtZXNzYWdlcyA9IGNvbnRleHQubWVzc2FnZXM7XG5cbiAgLy8gV2UgaGF2ZSB0byB3cmFwIHRoZSBhY3R1YWwgaG9vayBzbyB0aGUgdHlwZSBpbmZlcmVuY2UgZm9yIHRoZSBvcHRpb25hbFxuICAvLyBuYW1lc3BhY2Ugd29ya3MgY29ycmVjdGx5LiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzcxNTI5NTc1LzM0MzA0NVxuICAvLyBUaGUgcHJlZml4IChcIiFcIikgaXMgYXJiaXRyYXJ5LlxuICByZXR1cm4gdXNlVHJhbnNsYXRpb25zSW1wbCh7XG4gICAgJyEnOiBtZXNzYWdlc1xuICB9LFxuICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gIG5hbWVzcGFjZSA/IFwiIS5cIi5jb25jYXQobmFtZXNwYWNlKSA6ICchJywgJyEnKTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm93KCkge1xuICByZXR1cm4gbmV3IERhdGUoKTtcbn1cblxuLyoqXG4gKiBSZWFkaW5nIHRoZSBjdXJyZW50IGRhdGUgdmlhIGBuZXcgRGF0ZSgpYCBpbiBjb21wb25lbnRzIHNob3VsZCBiZSBhdm9pZGVkLCBhc1xuICogaXQgY2F1c2VzIGNvbXBvbmVudHMgdG8gYmUgaW1wdXJlIGFuZCBjYW4gbGVhZCB0byBmbGFreSB0ZXN0cy4gSW5zdGVhZCwgdGhpc1xuICogaG9vayBjYW4gYmUgdXNlZC5cbiAqXG4gKiBCeSBkZWZhdWx0LCBpdCByZXR1cm5zIHRoZSB0aW1lIHdoZW4gdGhlIGNvbXBvbmVudCBtb3VudHMuIElmIGB1cGRhdGVJbnRlcnZhbGBcbiAqIGlzIHNwZWNpZmllZCwgdGhlIHZhbHVlIHdpbGwgYmUgdXBkYXRlZCBiYXNlZCBvbiB0aGUgaW50ZXJ2YWwuXG4gKlxuICogWW91IGNhbiBob3dldmVyIGFsc28gcmV0dXJuIGEgc3RhdGljIHZhbHVlIGZyb20gdGhpcyBob29rLCBpZiB5b3VcbiAqIGNvbmZpZ3VyZSB0aGUgYG5vd2AgcGFyYW1ldGVyIG9uIHRoZSBjb250ZXh0IHByb3ZpZGVyLiBOb3RlIGhvd2V2ZXIsXG4gKiB0aGF0IGlmIGB1cGRhdGVJbnRlcnZhbGAgaXMgY29uZmlndXJlZCBpbiB0aGlzIGNhc2UsIHRoZSBjb21wb25lbnRcbiAqIHdpbGwgaW5pdGlhbGl6ZSB3aXRoIHRoZSBnbG9iYWwgdmFsdWUsIGJ1dCB3aWxsIGFmdGVyd2FyZHMgdXBkYXRlXG4gKiBjb250aW51b3VzbHkgYmFzZWQgb24gdGhlIGludGVydmFsLlxuICpcbiAqIEZvciB1bml0IHRlc3RzLCB0aGlzIGNhbiBiZSBtb2NrZWQgdG8gYSBjb25zdGFudCB2YWx1ZS4gRm9yIGVuZC10by1lbmRcbiAqIHRlc3RpbmcsIGFuIGVudmlyb25tZW50IHBhcmFtZXRlciBjYW4gYmUgcGFzc2VkIHRvIHRoZSBgbm93YCBwYXJhbWV0ZXJcbiAqIG9mIHRoZSBwcm92aWRlciB0byBtb2NrIHRoaXMgdG8gYSBzdGF0aWMgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHVzZU5vdyhvcHRpb25zKSB7XG4gIGNvbnN0IHVwZGF0ZUludGVydmFsID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnVwZGF0ZUludGVydmFsO1xuICBjb25zdCB7XG4gICAgbm93OiBnbG9iYWxOb3dcbiAgfSA9IF91c2VMb2NhbGUudXNlSW50bENvbnRleHQoKTtcbiAgY29uc3QgW25vdywgc2V0Tm93XSA9IFJlYWN0LnVzZVN0YXRlKGdsb2JhbE5vdyB8fCBnZXROb3coKSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCF1cGRhdGVJbnRlcnZhbCkgcmV0dXJuO1xuICAgIGNvbnN0IGludGVydmFsSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBzZXROb3coZ2V0Tm93KCkpO1xuICAgIH0sIHVwZGF0ZUludGVydmFsKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcbiAgICB9O1xuICB9LCBbZ2xvYmFsTm93LCB1cGRhdGVJbnRlcnZhbF0pO1xuICByZXR1cm4gbm93O1xufVxuXG5mdW5jdGlvbiB1c2VUaW1lWm9uZSgpIHtcbiAgcmV0dXJuIF91c2VMb2NhbGUudXNlSW50bENvbnRleHQoKS50aW1lWm9uZTtcbn1cblxuZnVuY3Rpb24gdXNlTWVzc2FnZXMoKSB7XG4gIGNvbnN0IGNvbnRleHQgPSBfdXNlTG9jYWxlLnVzZUludGxDb250ZXh0KCk7XG4gIGlmICghY29udGV4dC5tZXNzYWdlcykge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gbWVzc2FnZXMgZm91bmQuIEhhdmUgeW91IGNvbmZpZ3VyZWQgdGhlbSBjb3JyZWN0bHk/IFNlZSBodHRwczovL25leHQtaW50bC1kb2NzLnZlcmNlbC5hcHAvZG9jcy9jb25maWd1cmF0aW9uI21lc3NhZ2VzJyApO1xuICB9XG4gIHJldHVybiBjb250ZXh0Lm1lc3NhZ2VzO1xufVxuXG5mdW5jdGlvbiB1c2VGb3JtYXR0ZXIoKSB7XG4gIGNvbnN0IHtcbiAgICBmb3JtYXRzLFxuICAgIGxvY2FsZSxcbiAgICBub3c6IGdsb2JhbE5vdyxcbiAgICBvbkVycm9yLFxuICAgIHRpbWVab25lXG4gIH0gPSBfdXNlTG9jYWxlLnVzZUludGxDb250ZXh0KCk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IGNyZWF0ZUZvcm1hdHRlci5jcmVhdGVGb3JtYXR0ZXIoe1xuICAgIGZvcm1hdHMsXG4gICAgbG9jYWxlLFxuICAgIG5vdzogZ2xvYmFsTm93LFxuICAgIG9uRXJyb3IsXG4gICAgdGltZVpvbmVcbiAgfSksIFtmb3JtYXRzLCBnbG9iYWxOb3csIGxvY2FsZSwgb25FcnJvciwgdGltZVpvbmVdKTtcbn1cblxuZXhwb3J0cy5JbnRsUHJvdmlkZXIgPSBfSW50bFByb3ZpZGVyLkludGxQcm92aWRlcjtcbmV4cG9ydHMudXNlTG9jYWxlID0gX3VzZUxvY2FsZS51c2VMb2NhbGU7XG5leHBvcnRzLnVzZUZvcm1hdHRlciA9IHVzZUZvcm1hdHRlcjtcbmV4cG9ydHMudXNlTWVzc2FnZXMgPSB1c2VNZXNzYWdlcztcbmV4cG9ydHMudXNlTm93ID0gdXNlTm93O1xuZXhwb3J0cy51c2VUaW1lWm9uZSA9IHVzZVRpbWVab25lO1xuZXhwb3J0cy51c2VUcmFuc2xhdGlvbnMgPSB1c2VUcmFuc2xhdGlvbnM7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJfSW50bFByb3ZpZGVyIiwicmVxdWlyZSIsIl91c2VMb2NhbGUiLCJSZWFjdCIsImNyZWF0ZUZvcm1hdHRlciIsImluaXRpYWxpemVDb25maWciLCJoYXNXYXJuZWRGb3JNaXNzaW5nVGltZXpvbmUiLCJpc1NlcnZlciIsInVzZVRyYW5zbGF0aW9uc0ltcGwiLCJhbGxNZXNzYWdlcyIsIm5hbWVzcGFjZSIsIm5hbWVzcGFjZVByZWZpeCIsImRlZmF1bHRUcmFuc2xhdGlvblZhbHVlcyIsImZvcm1hdHMiLCJnbG9iYWxGb3JtYXRzIiwiZ2V0TWVzc2FnZUZhbGxiYWNrIiwibG9jYWxlIiwibWVzc2FnZUZvcm1hdENhY2hlIiwib25FcnJvciIsInRpbWVab25lIiwidXNlSW50bENvbnRleHQiLCJyZXNvbHZlTmFtZXNwYWNlIiwiSW50bEVycm9yIiwiSW50bEVycm9yQ29kZSIsIkVOVklST05NRU5UX0ZBTExCQUNLIiwidHJhbnNsYXRlIiwidXNlTWVtbyIsImNyZWF0ZUJhc2VUcmFuc2xhdG9yIiwibWVzc2FnZXMiLCJ1c2VUcmFuc2xhdGlvbnMiLCJjb250ZXh0IiwiY29uY2F0IiwiZ2V0Tm93IiwiRGF0ZSIsInVzZU5vdyIsIm9wdGlvbnMiLCJ1cGRhdGVJbnRlcnZhbCIsIm5vdyIsImdsb2JhbE5vdyIsInNldE5vdyIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiaW50ZXJ2YWxJZCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsInVzZVRpbWVab25lIiwidXNlTWVzc2FnZXMiLCJFcnJvciIsInVzZUZvcm1hdHRlciIsIkludGxQcm92aWRlciIsInVzZUxvY2FsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/development/react.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/index.js":
/*!*********************************************!*\
  !*** ./node_modules/use-intl/dist/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./development/index.js */ \"(ssr)/./node_modules/use-intl/dist/development/index.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUlBLEtBQXlCLEVBQWMsRUFFMUMsTUFBTTtJQUNMQyw2SEFBeUI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wd2Etc2Fhcy8uL25vZGVfbW9kdWxlcy91c2UtaW50bC9kaXN0L2luZGV4LmpzPzdiMTEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcHJvZHVjdGlvbi9pbmRleC5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RldmVsb3BtZW50L2luZGV4LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/use-intl/dist/development/core.js":
/*!********************************************************!*\
  !*** ./node_modules/use-intl/dist/development/core.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar initializeConfig = __webpack_require__(/*! ./initializeConfig-c503e215.js */ \"(rsc)/./node_modules/use-intl/dist/development/initializeConfig-c503e215.js\");\nvar createFormatter = __webpack_require__(/*! ./createFormatter-4ce6f6c8.js */ \"(rsc)/./node_modules/use-intl/dist/development/createFormatter-4ce6f6c8.js\");\n__webpack_require__(/*! intl-messageformat */ \"(rsc)/./node_modules/intl-messageformat/lib/index.js\");\n__webpack_require__(/*! react */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react.js\");\nfunction createTranslatorImpl(_ref, namespacePrefix) {\n    let { getMessageFallback, messages, namespace, onError, ...rest } = _ref;\n    // The `namespacePrefix` is part of the type system.\n    // See the comment in the function invocation.\n    messages = messages[namespacePrefix];\n    namespace = createFormatter.resolveNamespace(namespace, namespacePrefix);\n    return createFormatter.createBaseTranslator({\n        ...rest,\n        onError,\n        getMessageFallback,\n        messages,\n        namespace\n    });\n}\n/**\n * Translates messages from the given namespace by using the ICU syntax.\n * See https://formatjs.io/docs/core-concepts/icu-syntax.\n *\n * If no namespace is provided, all available messages are returned.\n * The namespace can also indicate nesting by using a dot\n * (e.g. `namespace.Component`).\n */ function createTranslator(_ref) {\n    let { getMessageFallback = initializeConfig.defaultGetMessageFallback, messages, namespace, onError = initializeConfig.defaultOnError, ...rest } = _ref;\n    // We have to wrap the actual function so the type inference for the optional\n    // namespace works correctly. See https://stackoverflow.com/a/71529575/343045\n    // The prefix (\"!\") is arbitrary.\n    return createTranslatorImpl({\n        ...rest,\n        onError,\n        getMessageFallback,\n        // @ts-expect-error `messages` is allowed to be `undefined` here and will be handled internally\n        messages: {\n            \"!\": messages\n        },\n        namespace: namespace ? \"!.\".concat(namespace) : \"!\"\n    }, \"!\");\n}\nexports.IntlError = initializeConfig.IntlError;\nexports.IntlErrorCode = initializeConfig.IntlErrorCode;\nexports.initializeConfig = initializeConfig.initializeConfig;\nexports.createFormatter = createFormatter.createFormatter;\nexports.createTranslator = createTranslator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9jb3JlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBRTdELElBQUlDLG1CQUFtQkMsbUJBQU9BLENBQUM7QUFDL0IsSUFBSUMsa0JBQWtCRCxtQkFBT0EsQ0FBQztBQUM5QkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFFUixTQUFTRSxxQkFBcUJDLElBQUksRUFBRUMsZUFBZTtJQUNqRCxJQUFJLEVBQ0ZDLGtCQUFrQixFQUNsQkMsUUFBUSxFQUNSQyxTQUFTLEVBQ1RDLE9BQU8sRUFDUCxHQUFHQyxNQUNKLEdBQUdOO0lBQ0osb0RBQW9EO0lBQ3BELDhDQUE4QztJQUM5Q0csV0FBV0EsUUFBUSxDQUFDRixnQkFBZ0I7SUFDcENHLFlBQVlOLGdCQUFnQlMsZ0JBQWdCLENBQUNILFdBQVdIO0lBQ3hELE9BQU9ILGdCQUFnQlUsb0JBQW9CLENBQUM7UUFDMUMsR0FBR0YsSUFBSTtRQUNQRDtRQUNBSDtRQUNBQztRQUNBQztJQUNGO0FBQ0Y7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU0ssaUJBQWlCVCxJQUFJO0lBQzVCLElBQUksRUFDRkUscUJBQXFCTixpQkFBaUJjLHlCQUF5QixFQUMvRFAsUUFBUSxFQUNSQyxTQUFTLEVBQ1RDLFVBQVVULGlCQUFpQmUsY0FBYyxFQUN6QyxHQUFHTCxNQUNKLEdBQUdOO0lBQ0osNkVBQTZFO0lBQzdFLDZFQUE2RTtJQUM3RSxpQ0FBaUM7SUFDakMsT0FBT0QscUJBQXFCO1FBQzFCLEdBQUdPLElBQUk7UUFDUEQ7UUFDQUg7UUFDQSwrRkFBK0Y7UUFDL0ZDLFVBQVU7WUFDUixLQUFLQTtRQUNQO1FBQ0FDLFdBQVdBLFlBQVksS0FBS1EsTUFBTSxDQUFDUixhQUFhO0lBQ2xELEdBQUc7QUFDTDtBQUVBVixpQkFBaUIsR0FBR0UsaUJBQWlCaUIsU0FBUztBQUM5Q25CLHFCQUFxQixHQUFHRSxpQkFBaUJrQixhQUFhO0FBQ3REcEIsd0JBQXdCLEdBQUdFLGlCQUFpQkEsZ0JBQWdCO0FBQzVERix1QkFBdUIsR0FBR0ksZ0JBQWdCQSxlQUFlO0FBQ3pESix3QkFBd0IsR0FBR2UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wd2Etc2Fhcy8uL25vZGVfbW9kdWxlcy91c2UtaW50bC9kaXN0L2RldmVsb3BtZW50L2NvcmUuanM/ZGI4NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBpbml0aWFsaXplQ29uZmlnID0gcmVxdWlyZSgnLi9pbml0aWFsaXplQ29uZmlnLWM1MDNlMjE1LmpzJyk7XG52YXIgY3JlYXRlRm9ybWF0dGVyID0gcmVxdWlyZSgnLi9jcmVhdGVGb3JtYXR0ZXItNGNlNmY2YzguanMnKTtcbnJlcXVpcmUoJ2ludGwtbWVzc2FnZWZvcm1hdCcpO1xucmVxdWlyZSgncmVhY3QnKTtcblxuZnVuY3Rpb24gY3JlYXRlVHJhbnNsYXRvckltcGwoX3JlZiwgbmFtZXNwYWNlUHJlZml4KSB7XG4gIGxldCB7XG4gICAgZ2V0TWVzc2FnZUZhbGxiYWNrLFxuICAgIG1lc3NhZ2VzLFxuICAgIG5hbWVzcGFjZSxcbiAgICBvbkVycm9yLFxuICAgIC4uLnJlc3RcbiAgfSA9IF9yZWY7XG4gIC8vIFRoZSBgbmFtZXNwYWNlUHJlZml4YCBpcyBwYXJ0IG9mIHRoZSB0eXBlIHN5c3RlbS5cbiAgLy8gU2VlIHRoZSBjb21tZW50IGluIHRoZSBmdW5jdGlvbiBpbnZvY2F0aW9uLlxuICBtZXNzYWdlcyA9IG1lc3NhZ2VzW25hbWVzcGFjZVByZWZpeF07XG4gIG5hbWVzcGFjZSA9IGNyZWF0ZUZvcm1hdHRlci5yZXNvbHZlTmFtZXNwYWNlKG5hbWVzcGFjZSwgbmFtZXNwYWNlUHJlZml4KTtcbiAgcmV0dXJuIGNyZWF0ZUZvcm1hdHRlci5jcmVhdGVCYXNlVHJhbnNsYXRvcih7XG4gICAgLi4ucmVzdCxcbiAgICBvbkVycm9yLFxuICAgIGdldE1lc3NhZ2VGYWxsYmFjayxcbiAgICBtZXNzYWdlcyxcbiAgICBuYW1lc3BhY2VcbiAgfSk7XG59XG5cbi8qKlxuICogVHJhbnNsYXRlcyBtZXNzYWdlcyBmcm9tIHRoZSBnaXZlbiBuYW1lc3BhY2UgYnkgdXNpbmcgdGhlIElDVSBzeW50YXguXG4gKiBTZWUgaHR0cHM6Ly9mb3JtYXRqcy5pby9kb2NzL2NvcmUtY29uY2VwdHMvaWN1LXN5bnRheC5cbiAqXG4gKiBJZiBubyBuYW1lc3BhY2UgaXMgcHJvdmlkZWQsIGFsbCBhdmFpbGFibGUgbWVzc2FnZXMgYXJlIHJldHVybmVkLlxuICogVGhlIG5hbWVzcGFjZSBjYW4gYWxzbyBpbmRpY2F0ZSBuZXN0aW5nIGJ5IHVzaW5nIGEgZG90XG4gKiAoZS5nLiBgbmFtZXNwYWNlLkNvbXBvbmVudGApLlxuICovXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2xhdG9yKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBnZXRNZXNzYWdlRmFsbGJhY2sgPSBpbml0aWFsaXplQ29uZmlnLmRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2ssXG4gICAgbWVzc2FnZXMsXG4gICAgbmFtZXNwYWNlLFxuICAgIG9uRXJyb3IgPSBpbml0aWFsaXplQ29uZmlnLmRlZmF1bHRPbkVycm9yLFxuICAgIC4uLnJlc3RcbiAgfSA9IF9yZWY7XG4gIC8vIFdlIGhhdmUgdG8gd3JhcCB0aGUgYWN0dWFsIGZ1bmN0aW9uIHNvIHRoZSB0eXBlIGluZmVyZW5jZSBmb3IgdGhlIG9wdGlvbmFsXG4gIC8vIG5hbWVzcGFjZSB3b3JrcyBjb3JyZWN0bHkuIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNzE1Mjk1NzUvMzQzMDQ1XG4gIC8vIFRoZSBwcmVmaXggKFwiIVwiKSBpcyBhcmJpdHJhcnkuXG4gIHJldHVybiBjcmVhdGVUcmFuc2xhdG9ySW1wbCh7XG4gICAgLi4ucmVzdCxcbiAgICBvbkVycm9yLFxuICAgIGdldE1lc3NhZ2VGYWxsYmFjayxcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGBtZXNzYWdlc2AgaXMgYWxsb3dlZCB0byBiZSBgdW5kZWZpbmVkYCBoZXJlIGFuZCB3aWxsIGJlIGhhbmRsZWQgaW50ZXJuYWxseVxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAnISc6IG1lc3NhZ2VzXG4gICAgfSxcbiAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZSA/IFwiIS5cIi5jb25jYXQobmFtZXNwYWNlKSA6ICchJ1xuICB9LCAnIScpO1xufVxuXG5leHBvcnRzLkludGxFcnJvciA9IGluaXRpYWxpemVDb25maWcuSW50bEVycm9yO1xuZXhwb3J0cy5JbnRsRXJyb3JDb2RlID0gaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3JDb2RlO1xuZXhwb3J0cy5pbml0aWFsaXplQ29uZmlnID0gaW5pdGlhbGl6ZUNvbmZpZy5pbml0aWFsaXplQ29uZmlnO1xuZXhwb3J0cy5jcmVhdGVGb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIuY3JlYXRlRm9ybWF0dGVyO1xuZXhwb3J0cy5jcmVhdGVUcmFuc2xhdG9yID0gY3JlYXRlVHJhbnNsYXRvcjtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImluaXRpYWxpemVDb25maWciLCJyZXF1aXJlIiwiY3JlYXRlRm9ybWF0dGVyIiwiY3JlYXRlVHJhbnNsYXRvckltcGwiLCJfcmVmIiwibmFtZXNwYWNlUHJlZml4IiwiZ2V0TWVzc2FnZUZhbGxiYWNrIiwibWVzc2FnZXMiLCJuYW1lc3BhY2UiLCJvbkVycm9yIiwicmVzdCIsInJlc29sdmVOYW1lc3BhY2UiLCJjcmVhdGVCYXNlVHJhbnNsYXRvciIsImNyZWF0ZVRyYW5zbGF0b3IiLCJkZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrIiwiZGVmYXVsdE9uRXJyb3IiLCJjb25jYXQiLCJJbnRsRXJyb3IiLCJJbnRsRXJyb3JDb2RlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/use-intl/dist/development/core.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/use-intl/dist/development/createFormatter-4ce6f6c8.js":
/*!****************************************************************************!*\
  !*** ./node_modules/use-intl/dist/development/createFormatter-4ce6f6c8.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar IntlMessageFormat = __webpack_require__(/*! intl-messageformat */ \"(rsc)/./node_modules/intl-messageformat/lib/index.js\");\nvar React = __webpack_require__(/*! react */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react.js\");\nvar initializeConfig = __webpack_require__(/*! ./initializeConfig-c503e215.js */ \"(rsc)/./node_modules/use-intl/dist/development/initializeConfig-c503e215.js\");\nfunction _interopDefault(e) {\n    return e && e.__esModule ? e : {\n        default: e\n    };\n}\nvar IntlMessageFormat__default = /*#__PURE__*/ _interopDefault(IntlMessageFormat);\n// eslint-disable-next-line import/no-named-as-default -- False positive\nfunction setTimeZoneInFormats(formats, timeZone) {\n    if (!formats) return formats;\n    // The only way to set a time zone with `intl-messageformat` is to merge it into the formats\n    // https://github.com/formatjs/formatjs/blob/8256c5271505cf2606e48e3c97ecdd16ede4f1b5/packages/intl/src/message.ts#L15\n    return Object.keys(formats).reduce((acc, key)=>{\n        acc[key] = {\n            timeZone,\n            ...formats[key]\n        };\n        return acc;\n    }, {});\n}\n/**\n * `intl-messageformat` uses separate keys for `date` and `time`, but there's\n * only one native API: `Intl.DateTimeFormat`. Additionally you might want to\n * include both a time and a date in a value, therefore the separation doesn't\n * seem so useful. We offer a single `dateTime` namespace instead, but we have\n * to convert the format before `intl-messageformat` can be used.\n */ function convertFormatsToIntlMessageFormat(formats, timeZone) {\n    const formatsWithTimeZone = timeZone ? {\n        ...formats,\n        dateTime: setTimeZoneInFormats(formats.dateTime, timeZone)\n    } : formats;\n    const mfDateDefaults = IntlMessageFormat__default.default.formats.date;\n    const defaultDateFormats = timeZone ? setTimeZoneInFormats(mfDateDefaults, timeZone) : mfDateDefaults;\n    const mfTimeDefaults = IntlMessageFormat__default.default.formats.time;\n    const defaultTimeFormats = timeZone ? setTimeZoneInFormats(mfTimeDefaults, timeZone) : mfTimeDefaults;\n    return {\n        ...formatsWithTimeZone,\n        date: {\n            ...defaultDateFormats,\n            ...formatsWithTimeZone === null || formatsWithTimeZone === void 0 ? void 0 : formatsWithTimeZone.dateTime\n        },\n        time: {\n            ...defaultTimeFormats,\n            ...formatsWithTimeZone === null || formatsWithTimeZone === void 0 ? void 0 : formatsWithTimeZone.dateTime\n        }\n    };\n}\n// eslint-disable-next-line import/no-named-as-default -- False positive\nfunction resolvePath(locale, messages, key, namespace) {\n    const fullKey = initializeConfig.joinPath(namespace, key);\n    if (!messages) {\n        throw new Error(\"No messages available at `\".concat(namespace, \"`.\"));\n    }\n    let message = messages;\n    key.split(\".\").forEach((part)=>{\n        const next = message[part];\n        if (part == null || next == null) {\n            throw new Error(\"Could not resolve `\".concat(fullKey, \"` in messages for locale `\").concat(locale, \"`.\"));\n        }\n        message = next;\n    });\n    return message;\n}\nfunction prepareTranslationValues(values) {\n    if (Object.keys(values).length === 0) return undefined;\n    // Workaround for https://github.com/formatjs/formatjs/issues/1467\n    const transformedValues = {};\n    Object.keys(values).forEach((key)=>{\n        let index = 0;\n        const value = values[key];\n        let transformed;\n        if (typeof value === \"function\") {\n            transformed = (chunks)=>{\n                const result = value(chunks);\n                return /*#__PURE__*/ React.isValidElement(result) ? /*#__PURE__*/ React.cloneElement(result, {\n                    key: key + index++\n                }) : result;\n            };\n        } else {\n            transformed = value;\n        }\n        transformedValues[key] = transformed;\n    });\n    return transformedValues;\n}\nfunction getMessagesOrError(locale, messages, namespace) {\n    let onError = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : initializeConfig.defaultOnError;\n    try {\n        if (!messages) {\n            throw new Error(\"No messages were configured on the provider.\");\n        }\n        const retrievedMessages = namespace ? resolvePath(locale, messages, namespace) : messages;\n        if (!retrievedMessages) {\n            throw new Error(\"No messages for namespace `\".concat(namespace, \"` found.\"));\n        }\n        return retrievedMessages;\n    } catch (error) {\n        const intlError = new initializeConfig.IntlError(initializeConfig.IntlErrorCode.MISSING_MESSAGE, error.message);\n        onError(intlError);\n        return intlError;\n    }\n}\nfunction getPlainMessage(candidate, values) {\n    if (values) return undefined;\n    const unescapedMessage = candidate.replace(/'([{}])/gi, \"$1\");\n    // Placeholders can be in the message if there are default values,\n    // or if the user has forgotten to provide values. In the latter\n    // case we need to compile the message to receive an error.\n    const hasPlaceholders = /<|{/.test(unescapedMessage);\n    if (!hasPlaceholders) {\n        return unescapedMessage;\n    }\n    return undefined;\n}\nfunction createBaseTranslator(config) {\n    const messagesOrError = getMessagesOrError(config.locale, config.messages, config.namespace, config.onError);\n    return createBaseTranslatorImpl({\n        ...config,\n        messagesOrError\n    });\n}\nfunction createBaseTranslatorImpl(_ref) {\n    let { defaultTranslationValues, formats: globalFormats, getMessageFallback = initializeConfig.defaultGetMessageFallback, locale, messageFormatCache, messagesOrError, namespace, onError, timeZone } = _ref;\n    function getFallbackFromErrorAndNotify(key, code, message) {\n        const error = new initializeConfig.IntlError(code, message);\n        onError(error);\n        return getMessageFallback({\n            error,\n            key,\n            namespace\n        });\n    }\n    function translateBaseFn(/** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */ key, /** Key value pairs for values to interpolate into the message. */ values, /** Provide custom formats for numbers, dates and times. */ formats) {\n        if (messagesOrError instanceof initializeConfig.IntlError) {\n            // We have already warned about this during render\n            return getMessageFallback({\n                error: messagesOrError,\n                key,\n                namespace\n            });\n        }\n        const messages = messagesOrError;\n        let message;\n        try {\n            message = resolvePath(locale, messages, key, namespace);\n        } catch (error) {\n            return getFallbackFromErrorAndNotify(key, initializeConfig.IntlErrorCode.MISSING_MESSAGE, error.message);\n        }\n        const cacheKey = initializeConfig.joinPath(locale, namespace, key, String(message));\n        let messageFormat;\n        if (messageFormatCache !== null && messageFormatCache !== void 0 && messageFormatCache.has(cacheKey)) {\n            messageFormat = messageFormatCache.get(cacheKey);\n        } else {\n            if (typeof message === \"object\") {\n                let code, errorMessage;\n                if (Array.isArray(message)) {\n                    code = initializeConfig.IntlErrorCode.INVALID_MESSAGE;\n                    {\n                        errorMessage = \"Message at `\".concat(initializeConfig.joinPath(namespace, key), \"` resolved to an array, but only strings are supported. See https://next-intl-docs.vercel.app/docs/usage/messages#arrays-of-messages\");\n                    }\n                } else {\n                    code = initializeConfig.IntlErrorCode.INSUFFICIENT_PATH;\n                    {\n                        errorMessage = \"Message at `\".concat(initializeConfig.joinPath(namespace, key), \"` resolved to an object, but only strings are supported. Use a `.` to retrieve nested messages. See https://next-intl-docs.vercel.app/docs/usage/messages#structuring-messages\");\n                    }\n                }\n                return getFallbackFromErrorAndNotify(key, code, errorMessage);\n            }\n            // Hot path that avoids creating an `IntlMessageFormat` instance\n            const plainMessage = getPlainMessage(message, values);\n            if (plainMessage) return plainMessage;\n            try {\n                messageFormat = new IntlMessageFormat__default.default(message, locale, convertFormatsToIntlMessageFormat({\n                    ...globalFormats,\n                    ...formats\n                }, timeZone), {\n                    formatters: {\n                        getNumberFormat (locales, options) {\n                            return new Intl.NumberFormat(locales, options);\n                        },\n                        getDateTimeFormat (locales, options) {\n                            // Workaround for https://github.com/formatjs/formatjs/issues/4279\n                            return new Intl.DateTimeFormat(locales, {\n                                timeZone,\n                                ...options\n                            });\n                        },\n                        getPluralRules (locales, options) {\n                            return new Intl.PluralRules(locales, options);\n                        }\n                    }\n                });\n            } catch (error) {\n                const thrownError = error;\n                return getFallbackFromErrorAndNotify(key, initializeConfig.IntlErrorCode.INVALID_MESSAGE, thrownError.message + (\"originalMessage\" in thrownError ? \" (\".concat(thrownError.originalMessage, \")\") : \"\"));\n            }\n            messageFormatCache === null || messageFormatCache === void 0 || messageFormatCache.set(cacheKey, messageFormat);\n        }\n        try {\n            const formattedMessage = messageFormat.format(// @ts-expect-error `intl-messageformat` expects a different format\n            // for rich text elements since a recent minor update. This\n            // needs to be evaluated in detail, possibly also in regards\n            // to be able to format to parts.\n            prepareTranslationValues({\n                ...defaultTranslationValues,\n                ...values\n            }));\n            if (formattedMessage == null) {\n                throw new Error(\"Unable to format `\".concat(key, \"` in \").concat(namespace ? \"namespace `\".concat(namespace, \"`\") : \"messages\"));\n            }\n            // Limit the function signature to return strings or React elements\n            return /*#__PURE__*/ React.isValidElement(formattedMessage) || // Arrays of React elements\n            Array.isArray(formattedMessage) || typeof formattedMessage === \"string\" ? formattedMessage : String(formattedMessage);\n        } catch (error) {\n            return getFallbackFromErrorAndNotify(key, initializeConfig.IntlErrorCode.FORMATTING_ERROR, error.message);\n        }\n    }\n    function translateFn(/** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */ key, /** Key value pairs for values to interpolate into the message. */ values, /** Provide custom formats for numbers, dates and times. */ formats) {\n        const result = translateBaseFn(key, values, formats);\n        if (typeof result !== \"string\") {\n            return getFallbackFromErrorAndNotify(key, initializeConfig.IntlErrorCode.INVALID_MESSAGE, \"The message `\".concat(key, \"` in \").concat(namespace ? \"namespace `\".concat(namespace, \"`\") : \"messages\", \" didn't resolve to a string. If you want to format rich text, use `t.rich` instead.\"));\n        }\n        return result;\n    }\n    translateFn.rich = translateBaseFn;\n    // Augment `translateBaseFn` to return plain strings\n    translateFn.markup = (key, values, formats)=>{\n        const result = translateBaseFn(key, // @ts-expect-error -- `MarkupTranslationValues` is practically a sub type\n        // of `RichTranslationValues` but TypeScript isn't smart enough here.\n        values, formats);\n        // When only string chunks are provided to the parser, only\n        // strings should be returned here. Note that we need a runtime\n        // check for this since rich text values could be accidentally\n        // inherited from `defaultTranslationValues`.\n        if (typeof result !== \"string\") {\n            const error = new initializeConfig.IntlError(initializeConfig.IntlErrorCode.FORMATTING_ERROR, \"`t.markup` only accepts functions for formatting that receive and return strings.\\n\\nE.g. t.markup('markup', {b: (chunks) => `<b>${chunks}</b>`})\");\n            onError(error);\n            return getMessageFallback({\n                error,\n                key,\n                namespace\n            });\n        }\n        return result;\n    };\n    translateFn.raw = (key)=>{\n        if (messagesOrError instanceof initializeConfig.IntlError) {\n            // We have already warned about this during render\n            return getMessageFallback({\n                error: messagesOrError,\n                key,\n                namespace\n            });\n        }\n        const messages = messagesOrError;\n        try {\n            return resolvePath(locale, messages, key, namespace);\n        } catch (error) {\n            return getFallbackFromErrorAndNotify(key, initializeConfig.IntlErrorCode.MISSING_MESSAGE, error.message);\n        }\n    };\n    return translateFn;\n}\n/**\n * For the strictly typed messages to work we have to wrap the namespace into\n * a mandatory prefix. See https://stackoverflow.com/a/71529575/343045\n */ function resolveNamespace(namespace, namespacePrefix) {\n    return namespace === namespacePrefix ? undefined : namespace.slice((namespacePrefix + \".\").length);\n}\nconst SECOND = 1;\nconst MINUTE = SECOND * 60;\nconst HOUR = MINUTE * 60;\nconst DAY = HOUR * 24;\nconst WEEK = DAY * 7;\nconst MONTH = DAY * (365 / 12); // Approximation\nconst QUARTER = MONTH * 3;\nconst YEAR = DAY * 365;\nconst UNIT_SECONDS = {\n    second: SECOND,\n    seconds: SECOND,\n    minute: MINUTE,\n    minutes: MINUTE,\n    hour: HOUR,\n    hours: HOUR,\n    day: DAY,\n    days: DAY,\n    week: WEEK,\n    weeks: WEEK,\n    month: MONTH,\n    months: MONTH,\n    quarter: QUARTER,\n    quarters: QUARTER,\n    year: YEAR,\n    years: YEAR\n};\nfunction resolveRelativeTimeUnit(seconds) {\n    const absValue = Math.abs(seconds);\n    if (absValue < MINUTE) {\n        return \"second\";\n    } else if (absValue < HOUR) {\n        return \"minute\";\n    } else if (absValue < DAY) {\n        return \"hour\";\n    } else if (absValue < WEEK) {\n        return \"day\";\n    } else if (absValue < MONTH) {\n        return \"week\";\n    } else if (absValue < YEAR) {\n        return \"month\";\n    }\n    return \"year\";\n}\nfunction calculateRelativeTimeValue(seconds, unit) {\n    // We have to round the resulting values, as `Intl.RelativeTimeFormat`\n    // will include fractions like '2.1 hours ago'.\n    return Math.round(seconds / UNIT_SECONDS[unit]);\n}\nfunction createFormatter(_ref) {\n    let { formats, locale, now: globalNow, onError = initializeConfig.defaultOnError, timeZone: globalTimeZone } = _ref;\n    function resolveFormatOrOptions(typeFormats, formatOrOptions) {\n        let options;\n        if (typeof formatOrOptions === \"string\") {\n            const formatName = formatOrOptions;\n            options = typeFormats === null || typeFormats === void 0 ? void 0 : typeFormats[formatName];\n            if (!options) {\n                const error = new initializeConfig.IntlError(initializeConfig.IntlErrorCode.MISSING_FORMAT, \"Format `\".concat(formatName, \"` is not available. You can configure it on the provider or provide custom options.\"));\n                onError(error);\n                throw error;\n            }\n        } else {\n            options = formatOrOptions;\n        }\n        return options;\n    }\n    function getFormattedValue(formatOrOptions, typeFormats, formatter, getFallback) {\n        let options;\n        try {\n            options = resolveFormatOrOptions(typeFormats, formatOrOptions);\n        } catch (error) {\n            return getFallback();\n        }\n        try {\n            return formatter(options);\n        } catch (error) {\n            onError(new initializeConfig.IntlError(initializeConfig.IntlErrorCode.FORMATTING_ERROR, error.message));\n            return getFallback();\n        }\n    }\n    function dateTime(/** If a number is supplied, this is interpreted as a UTC timestamp. */ value, /** If a time zone is supplied, the `value` is converted to that time zone.\n   * Otherwise the user time zone will be used. */ formatOrOptions) {\n        return getFormattedValue(formatOrOptions, formats === null || formats === void 0 ? void 0 : formats.dateTime, (options)=>{\n            var _options;\n            if (!((_options = options) !== null && _options !== void 0 && _options.timeZone)) {\n                if (globalTimeZone) {\n                    options = {\n                        ...options,\n                        timeZone: globalTimeZone\n                    };\n                } else {\n                    onError(new initializeConfig.IntlError(initializeConfig.IntlErrorCode.ENVIRONMENT_FALLBACK, \"The `timeZone` parameter wasn't provided and there is no global default configured. Consider adding a global default to avoid markup mismatches caused by environment differences. Learn more: https://next-intl-docs.vercel.app/docs/configuration#time-zone\"));\n                }\n            }\n            return new Intl.DateTimeFormat(locale, options).format(value);\n        }, ()=>String(value));\n    }\n    function number(value, formatOrOptions) {\n        return getFormattedValue(formatOrOptions, formats === null || formats === void 0 ? void 0 : formats.number, (options)=>new Intl.NumberFormat(locale, options).format(value), ()=>String(value));\n    }\n    function getGlobalNow() {\n        if (globalNow) {\n            return globalNow;\n        } else {\n            onError(new initializeConfig.IntlError(initializeConfig.IntlErrorCode.ENVIRONMENT_FALLBACK, \"The `now` parameter wasn't provided and there is no global default configured. Consider adding a global default to avoid markup mismatches caused by environment differences. Learn more: https://next-intl-docs.vercel.app/docs/configuration#now\"));\n            return new Date();\n        }\n    }\n    function extractNowDate(nowOrOptions) {\n        if (nowOrOptions instanceof Date || typeof nowOrOptions === \"number\") {\n            return new Date(nowOrOptions);\n        }\n        if ((nowOrOptions === null || nowOrOptions === void 0 ? void 0 : nowOrOptions.now) !== undefined) {\n            return new Date(nowOrOptions.now);\n        }\n        return getGlobalNow();\n    }\n    function relativeTime(/** The date time that needs to be formatted. */ date, /** The reference point in time to which `date` will be formatted in relation to.  */ nowOrOptions) {\n        try {\n            const dateDate = new Date(date);\n            const nowDate = extractNowDate(nowOrOptions);\n            const seconds = (dateDate.getTime() - nowDate.getTime()) / 1000;\n            const unit = typeof nowOrOptions === \"number\" || nowOrOptions instanceof Date || (nowOrOptions === null || nowOrOptions === void 0 ? void 0 : nowOrOptions.unit) === undefined ? resolveRelativeTimeUnit(seconds) : nowOrOptions.unit;\n            const value = calculateRelativeTimeValue(seconds, unit);\n            return new Intl.RelativeTimeFormat(locale, {\n                // `numeric: 'auto'` can theoretically produce output like \"yesterday\",\n                // but it only works with integers. E.g. -1 day will produce \"yesterday\",\n                // but -1.1 days will produce \"-1.1 days\". Rounding before formatting is\n                // not desired, as the given dates might cross a threshold were the\n                // output isn't correct anymore. Example: 2024-01-08T23:00:00.000Z and\n                // 2024-01-08T01:00:00.000Z would produce \"yesterday\", which is not the\n                // case. By using `always` we can ensure correct output. The only exception\n                // is the formatting of times <1 second as \"now\".\n                numeric: unit === \"second\" ? \"auto\" : \"always\"\n            }).format(value, unit);\n        } catch (error) {\n            onError(new initializeConfig.IntlError(initializeConfig.IntlErrorCode.FORMATTING_ERROR, error.message));\n            return String(date);\n        }\n    }\n    function list(value, formatOrOptions) {\n        const serializedValue = [];\n        const richValues = new Map();\n        // `formatToParts` only accepts strings, therefore we have to temporarily\n        // replace React elements with a placeholder ID that can be used to retrieve\n        // the original value afterwards.\n        let index = 0;\n        for (const item of value){\n            let serializedItem;\n            if (typeof item === \"object\") {\n                serializedItem = String(index);\n                richValues.set(serializedItem, item);\n            } else {\n                serializedItem = String(item);\n            }\n            serializedValue.push(serializedItem);\n            index++;\n        }\n        return getFormattedValue(formatOrOptions, formats === null || formats === void 0 ? void 0 : formats.list, // @ts-expect-error -- `richValues.size` is used to determine the return type, but TypeScript can't infer the meaning of this correctly\n        (options)=>{\n            const result = new Intl.ListFormat(locale, options).formatToParts(serializedValue).map((part)=>part.type === \"literal\" ? part.value : richValues.get(part.value) || part.value);\n            if (richValues.size > 0) {\n                return result;\n            } else {\n                return result.join(\"\");\n            }\n        }, ()=>String(value));\n    }\n    return {\n        dateTime,\n        number,\n        relativeTime,\n        list\n    };\n}\nexports.createBaseTranslator = createBaseTranslator;\nexports.createFormatter = createFormatter;\nexports.resolveNamespace = resolveNamespace;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9jcmVhdGVGb3JtYXR0ZXItNGNlNmY2YzguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxvQkFBb0JDLG1CQUFPQSxDQUFDO0FBQ2hDLElBQUlDLFFBQVFELG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlFLG1CQUFtQkYsbUJBQU9BLENBQUM7QUFFL0IsU0FBU0csZ0JBQWlCQyxDQUFDO0lBQUksT0FBT0EsS0FBS0EsRUFBRUMsVUFBVSxHQUFHRCxJQUFJO1FBQUVFLFNBQVNGO0lBQUU7QUFBRztBQUU5RSxJQUFJRyw2QkFBNkIsV0FBVyxHQUFFSixnQkFBZ0JKO0FBRTlELHdFQUF3RTtBQUN4RSxTQUFTUyxxQkFBcUJDLE9BQU8sRUFBRUMsUUFBUTtJQUM3QyxJQUFJLENBQUNELFNBQVMsT0FBT0E7SUFFckIsNEZBQTRGO0lBQzVGLHNIQUFzSDtJQUN0SCxPQUFPRSxPQUFPQyxJQUFJLENBQUNILFNBQVNJLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQztRQUN2Q0QsR0FBRyxDQUFDQyxJQUFJLEdBQUc7WUFDVEw7WUFDQSxHQUFHRCxPQUFPLENBQUNNLElBQUk7UUFDakI7UUFDQSxPQUFPRDtJQUNULEdBQUcsQ0FBQztBQUNOO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU0Usa0NBQWtDUCxPQUFPLEVBQUVDLFFBQVE7SUFDMUQsTUFBTU8sc0JBQXNCUCxXQUFXO1FBQ3JDLEdBQUdELE9BQU87UUFDVlMsVUFBVVYscUJBQXFCQyxRQUFRUyxRQUFRLEVBQUVSO0lBQ25ELElBQUlEO0lBQ0osTUFBTVUsaUJBQWlCWiwyQkFBMkJELE9BQU8sQ0FBQ0csT0FBTyxDQUFDVyxJQUFJO0lBQ3RFLE1BQU1DLHFCQUFxQlgsV0FBV0YscUJBQXFCVyxnQkFBZ0JULFlBQVlTO0lBQ3ZGLE1BQU1HLGlCQUFpQmYsMkJBQTJCRCxPQUFPLENBQUNHLE9BQU8sQ0FBQ2MsSUFBSTtJQUN0RSxNQUFNQyxx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Q1AsaUJBQWlCUSxHQUFHLENBQUMvSSxDQUFBQSxPQUFRQSxLQUFLZ0osSUFBSSxLQUFLLFlBQVloSixLQUFLUSxLQUFLLEdBQUdnSSxXQUFXekYsR0FBRyxDQUFDL0MsS0FBS1EsS0FBSyxLQUFLUixLQUFLUSxLQUFLO1lBQzlLLElBQUlnSSxXQUFXUyxJQUFJLEdBQUcsR0FBRztnQkFDdkIsT0FBT3RJO1lBQ1QsT0FBTztnQkFDTCxPQUFPQSxPQUFPdUksSUFBSSxDQUFDO1lBQ3JCO1FBQ0YsR0FBRyxJQUFNdEcsT0FBT3BDO0lBQ2xCO0lBQ0EsT0FBTztRQUNMMUI7UUFDQTZJO1FBQ0FLO1FBQ0FNO0lBQ0Y7QUFDRjtBQUVBYSw0QkFBNEIsR0FBR3JIO0FBQy9CcUgsdUJBQXVCLEdBQUd0QztBQUMxQnNDLHdCQUF3QixHQUFHekUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wd2Etc2Fhcy8uL25vZGVfbW9kdWxlcy91c2UtaW50bC9kaXN0L2RldmVsb3BtZW50L2NyZWF0ZUZvcm1hdHRlci00Y2U2ZjZjOC5qcz8wNDkxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIEludGxNZXNzYWdlRm9ybWF0ID0gcmVxdWlyZSgnaW50bC1tZXNzYWdlZm9ybWF0Jyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGluaXRpYWxpemVDb25maWcgPSByZXF1aXJlKCcuL2luaXRpYWxpemVDb25maWctYzUwM2UyMTUuanMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChlKSB7IHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7IGRlZmF1bHQ6IGUgfTsgfVxuXG52YXIgSW50bE1lc3NhZ2VGb3JtYXRfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0KEludGxNZXNzYWdlRm9ybWF0KTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1uYW1lZC1hcy1kZWZhdWx0IC0tIEZhbHNlIHBvc2l0aXZlXG5mdW5jdGlvbiBzZXRUaW1lWm9uZUluRm9ybWF0cyhmb3JtYXRzLCB0aW1lWm9uZSkge1xuICBpZiAoIWZvcm1hdHMpIHJldHVybiBmb3JtYXRzO1xuXG4gIC8vIFRoZSBvbmx5IHdheSB0byBzZXQgYSB0aW1lIHpvbmUgd2l0aCBgaW50bC1tZXNzYWdlZm9ybWF0YCBpcyB0byBtZXJnZSBpdCBpbnRvIHRoZSBmb3JtYXRzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mb3JtYXRqcy9mb3JtYXRqcy9ibG9iLzgyNTZjNTI3MTUwNWNmMjYwNmU0OGUzYzk3ZWNkZDE2ZWRlNGYxYjUvcGFja2FnZXMvaW50bC9zcmMvbWVzc2FnZS50cyNMMTVcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGZvcm1hdHMpLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICBhY2Nba2V5XSA9IHtcbiAgICAgIHRpbWVab25lLFxuICAgICAgLi4uZm9ybWF0c1trZXldXG4gICAgfTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG5cbi8qKlxuICogYGludGwtbWVzc2FnZWZvcm1hdGAgdXNlcyBzZXBhcmF0ZSBrZXlzIGZvciBgZGF0ZWAgYW5kIGB0aW1lYCwgYnV0IHRoZXJlJ3NcbiAqIG9ubHkgb25lIG5hdGl2ZSBBUEk6IGBJbnRsLkRhdGVUaW1lRm9ybWF0YC4gQWRkaXRpb25hbGx5IHlvdSBtaWdodCB3YW50IHRvXG4gKiBpbmNsdWRlIGJvdGggYSB0aW1lIGFuZCBhIGRhdGUgaW4gYSB2YWx1ZSwgdGhlcmVmb3JlIHRoZSBzZXBhcmF0aW9uIGRvZXNuJ3RcbiAqIHNlZW0gc28gdXNlZnVsLiBXZSBvZmZlciBhIHNpbmdsZSBgZGF0ZVRpbWVgIG5hbWVzcGFjZSBpbnN0ZWFkLCBidXQgd2UgaGF2ZVxuICogdG8gY29udmVydCB0aGUgZm9ybWF0IGJlZm9yZSBgaW50bC1tZXNzYWdlZm9ybWF0YCBjYW4gYmUgdXNlZC5cbiAqL1xuZnVuY3Rpb24gY29udmVydEZvcm1hdHNUb0ludGxNZXNzYWdlRm9ybWF0KGZvcm1hdHMsIHRpbWVab25lKSB7XG4gIGNvbnN0IGZvcm1hdHNXaXRoVGltZVpvbmUgPSB0aW1lWm9uZSA/IHtcbiAgICAuLi5mb3JtYXRzLFxuICAgIGRhdGVUaW1lOiBzZXRUaW1lWm9uZUluRm9ybWF0cyhmb3JtYXRzLmRhdGVUaW1lLCB0aW1lWm9uZSlcbiAgfSA6IGZvcm1hdHM7XG4gIGNvbnN0IG1mRGF0ZURlZmF1bHRzID0gSW50bE1lc3NhZ2VGb3JtYXRfX2RlZmF1bHQuZGVmYXVsdC5mb3JtYXRzLmRhdGU7XG4gIGNvbnN0IGRlZmF1bHREYXRlRm9ybWF0cyA9IHRpbWVab25lID8gc2V0VGltZVpvbmVJbkZvcm1hdHMobWZEYXRlRGVmYXVsdHMsIHRpbWVab25lKSA6IG1mRGF0ZURlZmF1bHRzO1xuICBjb25zdCBtZlRpbWVEZWZhdWx0cyA9IEludGxNZXNzYWdlRm9ybWF0X19kZWZhdWx0LmRlZmF1bHQuZm9ybWF0cy50aW1lO1xuICBjb25zdCBkZWZhdWx0VGltZUZvcm1hdHMgPSB0aW1lWm9uZSA/IHNldFRpbWVab25lSW5Gb3JtYXRzKG1mVGltZURlZmF1bHRzLCB0aW1lWm9uZSkgOiBtZlRpbWVEZWZhdWx0cztcbiAgcmV0dXJuIHtcbiAgICAuLi5mb3JtYXRzV2l0aFRpbWVab25lLFxuICAgIGRhdGU6IHtcbiAgICAgIC4uLmRlZmF1bHREYXRlRm9ybWF0cyxcbiAgICAgIC4uLihmb3JtYXRzV2l0aFRpbWVab25lID09PSBudWxsIHx8IGZvcm1hdHNXaXRoVGltZVpvbmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcm1hdHNXaXRoVGltZVpvbmUuZGF0ZVRpbWUpXG4gICAgfSxcbiAgICB0aW1lOiB7XG4gICAgICAuLi5kZWZhdWx0VGltZUZvcm1hdHMsXG4gICAgICAuLi4oZm9ybWF0c1dpdGhUaW1lWm9uZSA9PT0gbnVsbCB8fCBmb3JtYXRzV2l0aFRpbWVab25lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb3JtYXRzV2l0aFRpbWVab25lLmRhdGVUaW1lKVxuICAgIH1cbiAgfTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1uYW1lZC1hcy1kZWZhdWx0IC0tIEZhbHNlIHBvc2l0aXZlXG5mdW5jdGlvbiByZXNvbHZlUGF0aChsb2NhbGUsIG1lc3NhZ2VzLCBrZXksIG5hbWVzcGFjZSkge1xuICBjb25zdCBmdWxsS2V5ID0gaW5pdGlhbGl6ZUNvbmZpZy5qb2luUGF0aChuYW1lc3BhY2UsIGtleSk7XG4gIGlmICghbWVzc2FnZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBtZXNzYWdlcyBhdmFpbGFibGUgYXQgYFwiLmNvbmNhdChuYW1lc3BhY2UsIFwiYC5cIikgKTtcbiAgfVxuICBsZXQgbWVzc2FnZSA9IG1lc3NhZ2VzO1xuICBrZXkuc3BsaXQoJy4nKS5mb3JFYWNoKHBhcnQgPT4ge1xuICAgIGNvbnN0IG5leHQgPSBtZXNzYWdlW3BhcnRdO1xuICAgIGlmIChwYXJ0ID09IG51bGwgfHwgbmV4dCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcmVzb2x2ZSBgXCIuY29uY2F0KGZ1bGxLZXksIFwiYCBpbiBtZXNzYWdlcyBmb3IgbG9jYWxlIGBcIikuY29uY2F0KGxvY2FsZSwgXCJgLlwiKSApO1xuICAgIH1cbiAgICBtZXNzYWdlID0gbmV4dDtcbiAgfSk7XG4gIHJldHVybiBtZXNzYWdlO1xufVxuZnVuY3Rpb24gcHJlcGFyZVRyYW5zbGF0aW9uVmFsdWVzKHZhbHVlcykge1xuICBpZiAoT2JqZWN0LmtleXModmFsdWVzKS5sZW5ndGggPT09IDApIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2Zvcm1hdGpzL2Zvcm1hdGpzL2lzc3Vlcy8xNDY3XG4gIGNvbnN0IHRyYW5zZm9ybWVkVmFsdWVzID0ge307XG4gIE9iamVjdC5rZXlzKHZhbHVlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNba2V5XTtcbiAgICBsZXQgdHJhbnNmb3JtZWQ7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdHJhbnNmb3JtZWQgPSBjaHVua3MgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZShjaHVua3MpO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmlzVmFsaWRFbGVtZW50KHJlc3VsdCkgPyAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KHJlc3VsdCwge1xuICAgICAgICAgIGtleToga2V5ICsgaW5kZXgrK1xuICAgICAgICB9KSA6IHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zZm9ybWVkID0gdmFsdWU7XG4gICAgfVxuICAgIHRyYW5zZm9ybWVkVmFsdWVzW2tleV0gPSB0cmFuc2Zvcm1lZDtcbiAgfSk7XG4gIHJldHVybiB0cmFuc2Zvcm1lZFZhbHVlcztcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2VzT3JFcnJvcihsb2NhbGUsIG1lc3NhZ2VzLCBuYW1lc3BhY2UpIHtcbiAgbGV0IG9uRXJyb3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGluaXRpYWxpemVDb25maWcuZGVmYXVsdE9uRXJyb3I7XG4gIHRyeSB7XG4gICAgaWYgKCFtZXNzYWdlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gbWVzc2FnZXMgd2VyZSBjb25maWd1cmVkIG9uIHRoZSBwcm92aWRlci5cIiApO1xuICAgIH1cbiAgICBjb25zdCByZXRyaWV2ZWRNZXNzYWdlcyA9IG5hbWVzcGFjZSA/IHJlc29sdmVQYXRoKGxvY2FsZSwgbWVzc2FnZXMsIG5hbWVzcGFjZSkgOiBtZXNzYWdlcztcbiAgICBpZiAoIXJldHJpZXZlZE1lc3NhZ2VzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBtZXNzYWdlcyBmb3IgbmFtZXNwYWNlIGBcIi5jb25jYXQobmFtZXNwYWNlLCBcImAgZm91bmQuXCIpICk7XG4gICAgfVxuICAgIHJldHVybiByZXRyaWV2ZWRNZXNzYWdlcztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBpbnRsRXJyb3IgPSBuZXcgaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3IoaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3JDb2RlLk1JU1NJTkdfTUVTU0FHRSwgZXJyb3IubWVzc2FnZSk7XG4gICAgb25FcnJvcihpbnRsRXJyb3IpO1xuICAgIHJldHVybiBpbnRsRXJyb3I7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFBsYWluTWVzc2FnZShjYW5kaWRhdGUsIHZhbHVlcykge1xuICBpZiAodmFsdWVzKSByZXR1cm4gdW5kZWZpbmVkO1xuICBjb25zdCB1bmVzY2FwZWRNZXNzYWdlID0gY2FuZGlkYXRlLnJlcGxhY2UoLycoW3t9XSkvZ2ksICckMScpO1xuXG4gIC8vIFBsYWNlaG9sZGVycyBjYW4gYmUgaW4gdGhlIG1lc3NhZ2UgaWYgdGhlcmUgYXJlIGRlZmF1bHQgdmFsdWVzLFxuICAvLyBvciBpZiB0aGUgdXNlciBoYXMgZm9yZ290dGVuIHRvIHByb3ZpZGUgdmFsdWVzLiBJbiB0aGUgbGF0dGVyXG4gIC8vIGNhc2Ugd2UgbmVlZCB0byBjb21waWxlIHRoZSBtZXNzYWdlIHRvIHJlY2VpdmUgYW4gZXJyb3IuXG4gIGNvbnN0IGhhc1BsYWNlaG9sZGVycyA9IC88fHsvLnRlc3QodW5lc2NhcGVkTWVzc2FnZSk7XG4gIGlmICghaGFzUGxhY2Vob2xkZXJzKSB7XG4gICAgcmV0dXJuIHVuZXNjYXBlZE1lc3NhZ2U7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VUcmFuc2xhdG9yKGNvbmZpZykge1xuICBjb25zdCBtZXNzYWdlc09yRXJyb3IgPSBnZXRNZXNzYWdlc09yRXJyb3IoY29uZmlnLmxvY2FsZSwgY29uZmlnLm1lc3NhZ2VzLCBjb25maWcubmFtZXNwYWNlLCBjb25maWcub25FcnJvcik7XG4gIHJldHVybiBjcmVhdGVCYXNlVHJhbnNsYXRvckltcGwoe1xuICAgIC4uLmNvbmZpZyxcbiAgICBtZXNzYWdlc09yRXJyb3JcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVCYXNlVHJhbnNsYXRvckltcGwoX3JlZikge1xuICBsZXQge1xuICAgIGRlZmF1bHRUcmFuc2xhdGlvblZhbHVlcyxcbiAgICBmb3JtYXRzOiBnbG9iYWxGb3JtYXRzLFxuICAgIGdldE1lc3NhZ2VGYWxsYmFjayA9IGluaXRpYWxpemVDb25maWcuZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjayxcbiAgICBsb2NhbGUsXG4gICAgbWVzc2FnZUZvcm1hdENhY2hlLFxuICAgIG1lc3NhZ2VzT3JFcnJvcixcbiAgICBuYW1lc3BhY2UsXG4gICAgb25FcnJvcixcbiAgICB0aW1lWm9uZVxuICB9ID0gX3JlZjtcbiAgZnVuY3Rpb24gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBjb2RlLCBtZXNzYWdlKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3IoY29kZSwgbWVzc2FnZSk7XG4gICAgb25FcnJvcihlcnJvcik7XG4gICAgcmV0dXJuIGdldE1lc3NhZ2VGYWxsYmFjayh7XG4gICAgICBlcnJvcixcbiAgICAgIGtleSxcbiAgICAgIG5hbWVzcGFjZVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZUJhc2VGbiggLyoqIFVzZSBhIGRvdCB0byBpbmRpY2F0ZSBhIGxldmVsIG9mIG5lc3RpbmcgKGUuZy4gYG5hbWVzcGFjZS5uZXN0ZWRMYWJlbGApLiAqL1xuICBrZXksIC8qKiBLZXkgdmFsdWUgcGFpcnMgZm9yIHZhbHVlcyB0byBpbnRlcnBvbGF0ZSBpbnRvIHRoZSBtZXNzYWdlLiAqL1xuICB2YWx1ZXMsIC8qKiBQcm92aWRlIGN1c3RvbSBmb3JtYXRzIGZvciBudW1iZXJzLCBkYXRlcyBhbmQgdGltZXMuICovXG4gIGZvcm1hdHMpIHtcbiAgICBpZiAobWVzc2FnZXNPckVycm9yIGluc3RhbmNlb2YgaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3IpIHtcbiAgICAgIC8vIFdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgYWJvdXQgdGhpcyBkdXJpbmcgcmVuZGVyXG4gICAgICByZXR1cm4gZ2V0TWVzc2FnZUZhbGxiYWNrKHtcbiAgICAgICAgZXJyb3I6IG1lc3NhZ2VzT3JFcnJvcixcbiAgICAgICAga2V5LFxuICAgICAgICBuYW1lc3BhY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlcyA9IG1lc3NhZ2VzT3JFcnJvcjtcbiAgICBsZXQgbWVzc2FnZTtcbiAgICB0cnkge1xuICAgICAgbWVzc2FnZSA9IHJlc29sdmVQYXRoKGxvY2FsZSwgbWVzc2FnZXMsIGtleSwgbmFtZXNwYWNlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3JDb2RlLk1JU1NJTkdfTUVTU0FHRSwgZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlS2V5ID0gaW5pdGlhbGl6ZUNvbmZpZy5qb2luUGF0aChsb2NhbGUsIG5hbWVzcGFjZSwga2V5LCBTdHJpbmcobWVzc2FnZSkpO1xuICAgIGxldCBtZXNzYWdlRm9ybWF0O1xuICAgIGlmIChtZXNzYWdlRm9ybWF0Q2FjaGUgIT09IG51bGwgJiYgbWVzc2FnZUZvcm1hdENhY2hlICE9PSB2b2lkIDAgJiYgbWVzc2FnZUZvcm1hdENhY2hlLmhhcyhjYWNoZUtleSkpIHtcbiAgICAgIG1lc3NhZ2VGb3JtYXQgPSBtZXNzYWdlRm9ybWF0Q2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBsZXQgY29kZSwgZXJyb3JNZXNzYWdlO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtZXNzYWdlKSkge1xuICAgICAgICAgIGNvZGUgPSBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuSU5WQUxJRF9NRVNTQUdFO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IFwiTWVzc2FnZSBhdCBgXCIuY29uY2F0KGluaXRpYWxpemVDb25maWcuam9pblBhdGgobmFtZXNwYWNlLCBrZXkpLCBcImAgcmVzb2x2ZWQgdG8gYW4gYXJyYXksIGJ1dCBvbmx5IHN0cmluZ3MgYXJlIHN1cHBvcnRlZC4gU2VlIGh0dHBzOi8vbmV4dC1pbnRsLWRvY3MudmVyY2VsLmFwcC9kb2NzL3VzYWdlL21lc3NhZ2VzI2FycmF5cy1vZi1tZXNzYWdlc1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29kZSA9IGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZS5JTlNVRkZJQ0lFTlRfUEFUSDtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBcIk1lc3NhZ2UgYXQgYFwiLmNvbmNhdChpbml0aWFsaXplQ29uZmlnLmpvaW5QYXRoKG5hbWVzcGFjZSwga2V5KSwgXCJgIHJlc29sdmVkIHRvIGFuIG9iamVjdCwgYnV0IG9ubHkgc3RyaW5ncyBhcmUgc3VwcG9ydGVkLiBVc2UgYSBgLmAgdG8gcmV0cmlldmUgbmVzdGVkIG1lc3NhZ2VzLiBTZWUgaHR0cHM6Ly9uZXh0LWludGwtZG9jcy52ZXJjZWwuYXBwL2RvY3MvdXNhZ2UvbWVzc2FnZXMjc3RydWN0dXJpbmctbWVzc2FnZXNcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIGNvZGUsIGVycm9yTWVzc2FnZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEhvdCBwYXRoIHRoYXQgYXZvaWRzIGNyZWF0aW5nIGFuIGBJbnRsTWVzc2FnZUZvcm1hdGAgaW5zdGFuY2VcbiAgICAgIGNvbnN0IHBsYWluTWVzc2FnZSA9IGdldFBsYWluTWVzc2FnZShtZXNzYWdlLCB2YWx1ZXMpO1xuICAgICAgaWYgKHBsYWluTWVzc2FnZSkgcmV0dXJuIHBsYWluTWVzc2FnZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1lc3NhZ2VGb3JtYXQgPSBuZXcgSW50bE1lc3NhZ2VGb3JtYXRfX2RlZmF1bHQuZGVmYXVsdChtZXNzYWdlLCBsb2NhbGUsIGNvbnZlcnRGb3JtYXRzVG9JbnRsTWVzc2FnZUZvcm1hdCh7XG4gICAgICAgICAgLi4uZ2xvYmFsRm9ybWF0cyxcbiAgICAgICAgICAuLi5mb3JtYXRzXG4gICAgICAgIH0sIHRpbWVab25lKSwge1xuICAgICAgICAgIGZvcm1hdHRlcnM6IHtcbiAgICAgICAgICAgIGdldE51bWJlckZvcm1hdChsb2NhbGVzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlcywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0RGF0ZVRpbWVGb3JtYXQobG9jYWxlcywgb3B0aW9ucykge1xuICAgICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vZm9ybWF0anMvZm9ybWF0anMvaXNzdWVzLzQyNzlcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZXMsIHtcbiAgICAgICAgICAgICAgICB0aW1lWm9uZSxcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFBsdXJhbFJ1bGVzKGxvY2FsZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRsLlBsdXJhbFJ1bGVzKGxvY2FsZXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCB0aHJvd25FcnJvciA9IGVycm9yO1xuICAgICAgICByZXR1cm4gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuSU5WQUxJRF9NRVNTQUdFLCB0aHJvd25FcnJvci5tZXNzYWdlICsgKCdvcmlnaW5hbE1lc3NhZ2UnIGluIHRocm93bkVycm9yID8gXCIgKFwiLmNvbmNhdCh0aHJvd25FcnJvci5vcmlnaW5hbE1lc3NhZ2UsIFwiKVwiKSA6ICcnKSApO1xuICAgICAgfVxuICAgICAgbWVzc2FnZUZvcm1hdENhY2hlID09PSBudWxsIHx8IG1lc3NhZ2VGb3JtYXRDYWNoZSA9PT0gdm9pZCAwIHx8IG1lc3NhZ2VGb3JtYXRDYWNoZS5zZXQoY2FjaGVLZXksIG1lc3NhZ2VGb3JtYXQpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgZm9ybWF0dGVkTWVzc2FnZSA9IG1lc3NhZ2VGb3JtYXQuZm9ybWF0KFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgaW50bC1tZXNzYWdlZm9ybWF0YCBleHBlY3RzIGEgZGlmZmVyZW50IGZvcm1hdFxuICAgICAgLy8gZm9yIHJpY2ggdGV4dCBlbGVtZW50cyBzaW5jZSBhIHJlY2VudCBtaW5vciB1cGRhdGUuIFRoaXNcbiAgICAgIC8vIG5lZWRzIHRvIGJlIGV2YWx1YXRlZCBpbiBkZXRhaWwsIHBvc3NpYmx5IGFsc28gaW4gcmVnYXJkc1xuICAgICAgLy8gdG8gYmUgYWJsZSB0byBmb3JtYXQgdG8gcGFydHMuXG4gICAgICBwcmVwYXJlVHJhbnNsYXRpb25WYWx1ZXMoe1xuICAgICAgICAuLi5kZWZhdWx0VHJhbnNsYXRpb25WYWx1ZXMsXG4gICAgICAgIC4uLnZhbHVlc1xuICAgICAgfSkpO1xuICAgICAgaWYgKGZvcm1hdHRlZE1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZm9ybWF0IGBcIi5jb25jYXQoa2V5LCBcImAgaW4gXCIpLmNvbmNhdChuYW1lc3BhY2UgPyBcIm5hbWVzcGFjZSBgXCIuY29uY2F0KG5hbWVzcGFjZSwgXCJgXCIpIDogJ21lc3NhZ2VzJykgKTtcbiAgICAgIH1cblxuICAgICAgLy8gTGltaXQgdGhlIGZ1bmN0aW9uIHNpZ25hdHVyZSB0byByZXR1cm4gc3RyaW5ncyBvciBSZWFjdCBlbGVtZW50c1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5pc1ZhbGlkRWxlbWVudChmb3JtYXR0ZWRNZXNzYWdlKSB8fFxuICAgICAgLy8gQXJyYXlzIG9mIFJlYWN0IGVsZW1lbnRzXG4gICAgICBBcnJheS5pc0FycmF5KGZvcm1hdHRlZE1lc3NhZ2UpIHx8IHR5cGVvZiBmb3JtYXR0ZWRNZXNzYWdlID09PSAnc3RyaW5nJyA/IGZvcm1hdHRlZE1lc3NhZ2UgOiBTdHJpbmcoZm9ybWF0dGVkTWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZS5GT1JNQVRUSU5HX0VSUk9SLCBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHJhbnNsYXRlRm4oIC8qKiBVc2UgYSBkb3QgdG8gaW5kaWNhdGUgYSBsZXZlbCBvZiBuZXN0aW5nIChlLmcuIGBuYW1lc3BhY2UubmVzdGVkTGFiZWxgKS4gKi9cbiAga2V5LCAvKiogS2V5IHZhbHVlIHBhaXJzIGZvciB2YWx1ZXMgdG8gaW50ZXJwb2xhdGUgaW50byB0aGUgbWVzc2FnZS4gKi9cbiAgdmFsdWVzLCAvKiogUHJvdmlkZSBjdXN0b20gZm9ybWF0cyBmb3IgbnVtYmVycywgZGF0ZXMgYW5kIHRpbWVzLiAqL1xuICBmb3JtYXRzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdHJhbnNsYXRlQmFzZUZuKGtleSwgdmFsdWVzLCBmb3JtYXRzKTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZS5JTlZBTElEX01FU1NBR0UsIFwiVGhlIG1lc3NhZ2UgYFwiLmNvbmNhdChrZXksIFwiYCBpbiBcIikuY29uY2F0KG5hbWVzcGFjZSA/IFwibmFtZXNwYWNlIGBcIi5jb25jYXQobmFtZXNwYWNlLCBcImBcIikgOiAnbWVzc2FnZXMnLCBcIiBkaWRuJ3QgcmVzb2x2ZSB0byBhIHN0cmluZy4gSWYgeW91IHdhbnQgdG8gZm9ybWF0IHJpY2ggdGV4dCwgdXNlIGB0LnJpY2hgIGluc3RlYWQuXCIpICk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdHJhbnNsYXRlRm4ucmljaCA9IHRyYW5zbGF0ZUJhc2VGbjtcblxuICAvLyBBdWdtZW50IGB0cmFuc2xhdGVCYXNlRm5gIHRvIHJldHVybiBwbGFpbiBzdHJpbmdzXG4gIHRyYW5zbGF0ZUZuLm1hcmt1cCA9IChrZXksIHZhbHVlcywgZm9ybWF0cykgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRyYW5zbGF0ZUJhc2VGbihrZXksXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBgTWFya3VwVHJhbnNsYXRpb25WYWx1ZXNgIGlzIHByYWN0aWNhbGx5IGEgc3ViIHR5cGVcbiAgICAvLyBvZiBgUmljaFRyYW5zbGF0aW9uVmFsdWVzYCBidXQgVHlwZVNjcmlwdCBpc24ndCBzbWFydCBlbm91Z2ggaGVyZS5cbiAgICB2YWx1ZXMsIGZvcm1hdHMpO1xuXG4gICAgLy8gV2hlbiBvbmx5IHN0cmluZyBjaHVua3MgYXJlIHByb3ZpZGVkIHRvIHRoZSBwYXJzZXIsIG9ubHlcbiAgICAvLyBzdHJpbmdzIHNob3VsZCBiZSByZXR1cm5lZCBoZXJlLiBOb3RlIHRoYXQgd2UgbmVlZCBhIHJ1bnRpbWVcbiAgICAvLyBjaGVjayBmb3IgdGhpcyBzaW5jZSByaWNoIHRleHQgdmFsdWVzIGNvdWxkIGJlIGFjY2lkZW50YWxseVxuICAgIC8vIGluaGVyaXRlZCBmcm9tIGBkZWZhdWx0VHJhbnNsYXRpb25WYWx1ZXNgLlxuICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3IoaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3JDb2RlLkZPUk1BVFRJTkdfRVJST1IsIFwiYHQubWFya3VwYCBvbmx5IGFjY2VwdHMgZnVuY3Rpb25zIGZvciBmb3JtYXR0aW5nIHRoYXQgcmVjZWl2ZSBhbmQgcmV0dXJuIHN0cmluZ3MuXFxuXFxuRS5nLiB0Lm1hcmt1cCgnbWFya3VwJywge2I6IChjaHVua3MpID0+IGA8Yj4ke2NodW5rc308L2I+YH0pXCIgKTtcbiAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIGdldE1lc3NhZ2VGYWxsYmFjayh7XG4gICAgICAgIGVycm9yLFxuICAgICAgICBrZXksXG4gICAgICAgIG5hbWVzcGFjZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHRyYW5zbGF0ZUZuLnJhdyA9IGtleSA9PiB7XG4gICAgaWYgKG1lc3NhZ2VzT3JFcnJvciBpbnN0YW5jZW9mIGluaXRpYWxpemVDb25maWcuSW50bEVycm9yKSB7XG4gICAgICAvLyBXZSBoYXZlIGFscmVhZHkgd2FybmVkIGFib3V0IHRoaXMgZHVyaW5nIHJlbmRlclxuICAgICAgcmV0dXJuIGdldE1lc3NhZ2VGYWxsYmFjayh7XG4gICAgICAgIGVycm9yOiBtZXNzYWdlc09yRXJyb3IsXG4gICAgICAgIGtleSxcbiAgICAgICAgbmFtZXNwYWNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZXMgPSBtZXNzYWdlc09yRXJyb3I7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiByZXNvbHZlUGF0aChsb2NhbGUsIG1lc3NhZ2VzLCBrZXksIG5hbWVzcGFjZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZS5NSVNTSU5HX01FU1NBR0UsIGVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHRyYW5zbGF0ZUZuO1xufVxuXG4vKipcbiAqIEZvciB0aGUgc3RyaWN0bHkgdHlwZWQgbWVzc2FnZXMgdG8gd29yayB3ZSBoYXZlIHRvIHdyYXAgdGhlIG5hbWVzcGFjZSBpbnRvXG4gKiBhIG1hbmRhdG9yeSBwcmVmaXguIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNzE1Mjk1NzUvMzQzMDQ1XG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVOYW1lc3BhY2UobmFtZXNwYWNlLCBuYW1lc3BhY2VQcmVmaXgpIHtcbiAgcmV0dXJuIG5hbWVzcGFjZSA9PT0gbmFtZXNwYWNlUHJlZml4ID8gdW5kZWZpbmVkIDogbmFtZXNwYWNlLnNsaWNlKChuYW1lc3BhY2VQcmVmaXggKyAnLicpLmxlbmd0aCk7XG59XG5cbmNvbnN0IFNFQ09ORCA9IDE7XG5jb25zdCBNSU5VVEUgPSBTRUNPTkQgKiA2MDtcbmNvbnN0IEhPVVIgPSBNSU5VVEUgKiA2MDtcbmNvbnN0IERBWSA9IEhPVVIgKiAyNDtcbmNvbnN0IFdFRUsgPSBEQVkgKiA3O1xuY29uc3QgTU9OVEggPSBEQVkgKiAoMzY1IC8gMTIpOyAvLyBBcHByb3hpbWF0aW9uXG5jb25zdCBRVUFSVEVSID0gTU9OVEggKiAzO1xuY29uc3QgWUVBUiA9IERBWSAqIDM2NTtcbmNvbnN0IFVOSVRfU0VDT05EUyA9IHtcbiAgc2Vjb25kOiBTRUNPTkQsXG4gIHNlY29uZHM6IFNFQ09ORCxcbiAgbWludXRlOiBNSU5VVEUsXG4gIG1pbnV0ZXM6IE1JTlVURSxcbiAgaG91cjogSE9VUixcbiAgaG91cnM6IEhPVVIsXG4gIGRheTogREFZLFxuICBkYXlzOiBEQVksXG4gIHdlZWs6IFdFRUssXG4gIHdlZWtzOiBXRUVLLFxuICBtb250aDogTU9OVEgsXG4gIG1vbnRoczogTU9OVEgsXG4gIHF1YXJ0ZXI6IFFVQVJURVIsXG4gIHF1YXJ0ZXJzOiBRVUFSVEVSLFxuICB5ZWFyOiBZRUFSLFxuICB5ZWFyczogWUVBUlxufTtcbmZ1bmN0aW9uIHJlc29sdmVSZWxhdGl2ZVRpbWVVbml0KHNlY29uZHMpIHtcbiAgY29uc3QgYWJzVmFsdWUgPSBNYXRoLmFicyhzZWNvbmRzKTtcbiAgaWYgKGFic1ZhbHVlIDwgTUlOVVRFKSB7XG4gICAgcmV0dXJuICdzZWNvbmQnO1xuICB9IGVsc2UgaWYgKGFic1ZhbHVlIDwgSE9VUikge1xuICAgIHJldHVybiAnbWludXRlJztcbiAgfSBlbHNlIGlmIChhYnNWYWx1ZSA8IERBWSkge1xuICAgIHJldHVybiAnaG91cic7XG4gIH0gZWxzZSBpZiAoYWJzVmFsdWUgPCBXRUVLKSB7XG4gICAgcmV0dXJuICdkYXknO1xuICB9IGVsc2UgaWYgKGFic1ZhbHVlIDwgTU9OVEgpIHtcbiAgICByZXR1cm4gJ3dlZWsnO1xuICB9IGVsc2UgaWYgKGFic1ZhbHVlIDwgWUVBUikge1xuICAgIHJldHVybiAnbW9udGgnO1xuICB9XG4gIHJldHVybiAneWVhcic7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVSZWxhdGl2ZVRpbWVWYWx1ZShzZWNvbmRzLCB1bml0KSB7XG4gIC8vIFdlIGhhdmUgdG8gcm91bmQgdGhlIHJlc3VsdGluZyB2YWx1ZXMsIGFzIGBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdGBcbiAgLy8gd2lsbCBpbmNsdWRlIGZyYWN0aW9ucyBsaWtlICcyLjEgaG91cnMgYWdvJy5cbiAgcmV0dXJuIE1hdGgucm91bmQoc2Vjb25kcyAvIFVOSVRfU0VDT05EU1t1bml0XSk7XG59XG5mdW5jdGlvbiBjcmVhdGVGb3JtYXR0ZXIoX3JlZikge1xuICBsZXQge1xuICAgIGZvcm1hdHMsXG4gICAgbG9jYWxlLFxuICAgIG5vdzogZ2xvYmFsTm93LFxuICAgIG9uRXJyb3IgPSBpbml0aWFsaXplQ29uZmlnLmRlZmF1bHRPbkVycm9yLFxuICAgIHRpbWVab25lOiBnbG9iYWxUaW1lWm9uZVxuICB9ID0gX3JlZjtcbiAgZnVuY3Rpb24gcmVzb2x2ZUZvcm1hdE9yT3B0aW9ucyh0eXBlRm9ybWF0cywgZm9ybWF0T3JPcHRpb25zKSB7XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgaWYgKHR5cGVvZiBmb3JtYXRPck9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBmb3JtYXROYW1lID0gZm9ybWF0T3JPcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHR5cGVGb3JtYXRzID09PSBudWxsIHx8IHR5cGVGb3JtYXRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0eXBlRm9ybWF0c1tmb3JtYXROYW1lXTtcbiAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvcihpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuTUlTU0lOR19GT1JNQVQsIFwiRm9ybWF0IGBcIi5jb25jYXQoZm9ybWF0TmFtZSwgXCJgIGlzIG5vdCBhdmFpbGFibGUuIFlvdSBjYW4gY29uZmlndXJlIGl0IG9uIHRoZSBwcm92aWRlciBvciBwcm92aWRlIGN1c3RvbSBvcHRpb25zLlwiKSApO1xuICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSBmb3JtYXRPck9wdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG4gIGZ1bmN0aW9uIGdldEZvcm1hdHRlZFZhbHVlKGZvcm1hdE9yT3B0aW9ucywgdHlwZUZvcm1hdHMsIGZvcm1hdHRlciwgZ2V0RmFsbGJhY2spIHtcbiAgICBsZXQgb3B0aW9ucztcbiAgICB0cnkge1xuICAgICAgb3B0aW9ucyA9IHJlc29sdmVGb3JtYXRPck9wdGlvbnModHlwZUZvcm1hdHMsIGZvcm1hdE9yT3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFjaygpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcihvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgb25FcnJvcihuZXcgaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3IoaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3JDb2RlLkZPUk1BVFRJTkdfRVJST1IsIGVycm9yLm1lc3NhZ2UpKTtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkYXRlVGltZSggLyoqIElmIGEgbnVtYmVyIGlzIHN1cHBsaWVkLCB0aGlzIGlzIGludGVycHJldGVkIGFzIGEgVVRDIHRpbWVzdGFtcC4gKi9cbiAgdmFsdWUsXG4gIC8qKiBJZiBhIHRpbWUgem9uZSBpcyBzdXBwbGllZCwgdGhlIGB2YWx1ZWAgaXMgY29udmVydGVkIHRvIHRoYXQgdGltZSB6b25lLlxuICAgKiBPdGhlcndpc2UgdGhlIHVzZXIgdGltZSB6b25lIHdpbGwgYmUgdXNlZC4gKi9cbiAgZm9ybWF0T3JPcHRpb25zKSB7XG4gICAgcmV0dXJuIGdldEZvcm1hdHRlZFZhbHVlKGZvcm1hdE9yT3B0aW9ucywgZm9ybWF0cyA9PT0gbnVsbCB8fCBmb3JtYXRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb3JtYXRzLmRhdGVUaW1lLCBvcHRpb25zID0+IHtcbiAgICAgIHZhciBfb3B0aW9ucztcbiAgICAgIGlmICghKChfb3B0aW9ucyA9IG9wdGlvbnMpICE9PSBudWxsICYmIF9vcHRpb25zICE9PSB2b2lkIDAgJiYgX29wdGlvbnMudGltZVpvbmUpKSB7XG4gICAgICAgIGlmIChnbG9iYWxUaW1lWm9uZSkge1xuICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdGltZVpvbmU6IGdsb2JhbFRpbWVab25lXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbkVycm9yKG5ldyBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvcihpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuRU5WSVJPTk1FTlRfRkFMTEJBQ0ssIFwiVGhlIGB0aW1lWm9uZWAgcGFyYW1ldGVyIHdhc24ndCBwcm92aWRlZCBhbmQgdGhlcmUgaXMgbm8gZ2xvYmFsIGRlZmF1bHQgY29uZmlndXJlZC4gQ29uc2lkZXIgYWRkaW5nIGEgZ2xvYmFsIGRlZmF1bHQgdG8gYXZvaWQgbWFya3VwIG1pc21hdGNoZXMgY2F1c2VkIGJ5IGVudmlyb25tZW50IGRpZmZlcmVuY2VzLiBMZWFybiBtb3JlOiBodHRwczovL25leHQtaW50bC1kb2NzLnZlcmNlbC5hcHAvZG9jcy9jb25maWd1cmF0aW9uI3RpbWUtem9uZVwiICkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXQodmFsdWUpO1xuICAgIH0sICgpID0+IFN0cmluZyh2YWx1ZSkpO1xuICB9XG4gIGZ1bmN0aW9uIG51bWJlcih2YWx1ZSwgZm9ybWF0T3JPcHRpb25zKSB7XG4gICAgcmV0dXJuIGdldEZvcm1hdHRlZFZhbHVlKGZvcm1hdE9yT3B0aW9ucywgZm9ybWF0cyA9PT0gbnVsbCB8fCBmb3JtYXRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb3JtYXRzLm51bWJlciwgb3B0aW9ucyA9PiBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXQodmFsdWUpLCAoKSA9PiBTdHJpbmcodmFsdWUpKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRHbG9iYWxOb3coKSB7XG4gICAgaWYgKGdsb2JhbE5vdykge1xuICAgICAgcmV0dXJuIGdsb2JhbE5vdztcbiAgICB9IGVsc2Uge1xuICAgICAgb25FcnJvcihuZXcgaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3IoaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3JDb2RlLkVOVklST05NRU5UX0ZBTExCQUNLLCBcIlRoZSBgbm93YCBwYXJhbWV0ZXIgd2Fzbid0IHByb3ZpZGVkIGFuZCB0aGVyZSBpcyBubyBnbG9iYWwgZGVmYXVsdCBjb25maWd1cmVkLiBDb25zaWRlciBhZGRpbmcgYSBnbG9iYWwgZGVmYXVsdCB0byBhdm9pZCBtYXJrdXAgbWlzbWF0Y2hlcyBjYXVzZWQgYnkgZW52aXJvbm1lbnQgZGlmZmVyZW5jZXMuIExlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dC1pbnRsLWRvY3MudmVyY2VsLmFwcC9kb2NzL2NvbmZpZ3VyYXRpb24jbm93XCIgKSk7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZXh0cmFjdE5vd0RhdGUobm93T3JPcHRpb25zKSB7XG4gICAgaWYgKG5vd09yT3B0aW9ucyBpbnN0YW5jZW9mIERhdGUgfHwgdHlwZW9mIG5vd09yT3B0aW9ucyA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShub3dPck9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoKG5vd09yT3B0aW9ucyA9PT0gbnVsbCB8fCBub3dPck9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vd09yT3B0aW9ucy5ub3cpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShub3dPck9wdGlvbnMubm93KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEdsb2JhbE5vdygpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbGF0aXZlVGltZSggLyoqIFRoZSBkYXRlIHRpbWUgdGhhdCBuZWVkcyB0byBiZSBmb3JtYXR0ZWQuICovXG4gIGRhdGUsIC8qKiBUaGUgcmVmZXJlbmNlIHBvaW50IGluIHRpbWUgdG8gd2hpY2ggYGRhdGVgIHdpbGwgYmUgZm9ybWF0dGVkIGluIHJlbGF0aW9uIHRvLiAgKi9cbiAgbm93T3JPcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGVEYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgICBjb25zdCBub3dEYXRlID0gZXh0cmFjdE5vd0RhdGUobm93T3JPcHRpb25zKTtcbiAgICAgIGNvbnN0IHNlY29uZHMgPSAoZGF0ZURhdGUuZ2V0VGltZSgpIC0gbm93RGF0ZS5nZXRUaW1lKCkpIC8gMTAwMDtcbiAgICAgIGNvbnN0IHVuaXQgPSB0eXBlb2Ygbm93T3JPcHRpb25zID09PSAnbnVtYmVyJyB8fCBub3dPck9wdGlvbnMgaW5zdGFuY2VvZiBEYXRlIHx8IChub3dPck9wdGlvbnMgPT09IG51bGwgfHwgbm93T3JPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub3dPck9wdGlvbnMudW5pdCkgPT09IHVuZGVmaW5lZCA/IHJlc29sdmVSZWxhdGl2ZVRpbWVVbml0KHNlY29uZHMpIDogbm93T3JPcHRpb25zLnVuaXQ7XG4gICAgICBjb25zdCB2YWx1ZSA9IGNhbGN1bGF0ZVJlbGF0aXZlVGltZVZhbHVlKHNlY29uZHMsIHVuaXQpO1xuICAgICAgcmV0dXJuIG5ldyBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdChsb2NhbGUsIHtcbiAgICAgICAgLy8gYG51bWVyaWM6ICdhdXRvJ2AgY2FuIHRoZW9yZXRpY2FsbHkgcHJvZHVjZSBvdXRwdXQgbGlrZSBcInllc3RlcmRheVwiLFxuICAgICAgICAvLyBidXQgaXQgb25seSB3b3JrcyB3aXRoIGludGVnZXJzLiBFLmcuIC0xIGRheSB3aWxsIHByb2R1Y2UgXCJ5ZXN0ZXJkYXlcIixcbiAgICAgICAgLy8gYnV0IC0xLjEgZGF5cyB3aWxsIHByb2R1Y2UgXCItMS4xIGRheXNcIi4gUm91bmRpbmcgYmVmb3JlIGZvcm1hdHRpbmcgaXNcbiAgICAgICAgLy8gbm90IGRlc2lyZWQsIGFzIHRoZSBnaXZlbiBkYXRlcyBtaWdodCBjcm9zcyBhIHRocmVzaG9sZCB3ZXJlIHRoZVxuICAgICAgICAvLyBvdXRwdXQgaXNuJ3QgY29ycmVjdCBhbnltb3JlLiBFeGFtcGxlOiAyMDI0LTAxLTA4VDIzOjAwOjAwLjAwMFogYW5kXG4gICAgICAgIC8vIDIwMjQtMDEtMDhUMDE6MDA6MDAuMDAwWiB3b3VsZCBwcm9kdWNlIFwieWVzdGVyZGF5XCIsIHdoaWNoIGlzIG5vdCB0aGVcbiAgICAgICAgLy8gY2FzZS4gQnkgdXNpbmcgYGFsd2F5c2Agd2UgY2FuIGVuc3VyZSBjb3JyZWN0IG91dHB1dC4gVGhlIG9ubHkgZXhjZXB0aW9uXG4gICAgICAgIC8vIGlzIHRoZSBmb3JtYXR0aW5nIG9mIHRpbWVzIDwxIHNlY29uZCBhcyBcIm5vd1wiLlxuICAgICAgICBudW1lcmljOiB1bml0ID09PSAnc2Vjb25kJyA/ICdhdXRvJyA6ICdhbHdheXMnXG4gICAgICB9KS5mb3JtYXQodmFsdWUsIHVuaXQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBvbkVycm9yKG5ldyBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvcihpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuRk9STUFUVElOR19FUlJPUiwgZXJyb3IubWVzc2FnZSkpO1xuICAgICAgcmV0dXJuIFN0cmluZyhkYXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbGlzdCh2YWx1ZSwgZm9ybWF0T3JPcHRpb25zKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZFZhbHVlID0gW107XG4gICAgY29uc3QgcmljaFZhbHVlcyA9IG5ldyBNYXAoKTtcblxuICAgIC8vIGBmb3JtYXRUb1BhcnRzYCBvbmx5IGFjY2VwdHMgc3RyaW5ncywgdGhlcmVmb3JlIHdlIGhhdmUgdG8gdGVtcG9yYXJpbHlcbiAgICAvLyByZXBsYWNlIFJlYWN0IGVsZW1lbnRzIHdpdGggYSBwbGFjZWhvbGRlciBJRCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJldHJpZXZlXG4gICAgLy8gdGhlIG9yaWdpbmFsIHZhbHVlIGFmdGVyd2FyZHMuXG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgIGxldCBzZXJpYWxpemVkSXRlbTtcbiAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgc2VyaWFsaXplZEl0ZW0gPSBTdHJpbmcoaW5kZXgpO1xuICAgICAgICByaWNoVmFsdWVzLnNldChzZXJpYWxpemVkSXRlbSwgaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXJpYWxpemVkSXRlbSA9IFN0cmluZyhpdGVtKTtcbiAgICAgIH1cbiAgICAgIHNlcmlhbGl6ZWRWYWx1ZS5wdXNoKHNlcmlhbGl6ZWRJdGVtKTtcbiAgICAgIGluZGV4Kys7XG4gICAgfVxuICAgIHJldHVybiBnZXRGb3JtYXR0ZWRWYWx1ZShmb3JtYXRPck9wdGlvbnMsIGZvcm1hdHMgPT09IG51bGwgfHwgZm9ybWF0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm9ybWF0cy5saXN0LFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gYHJpY2hWYWx1ZXMuc2l6ZWAgaXMgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHJldHVybiB0eXBlLCBidXQgVHlwZVNjcmlwdCBjYW4ndCBpbmZlciB0aGUgbWVhbmluZyBvZiB0aGlzIGNvcnJlY3RseVxuICAgIG9wdGlvbnMgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEludGwuTGlzdEZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdFRvUGFydHMoc2VyaWFsaXplZFZhbHVlKS5tYXAocGFydCA9PiBwYXJ0LnR5cGUgPT09ICdsaXRlcmFsJyA/IHBhcnQudmFsdWUgOiByaWNoVmFsdWVzLmdldChwYXJ0LnZhbHVlKSB8fCBwYXJ0LnZhbHVlKTtcbiAgICAgIGlmIChyaWNoVmFsdWVzLnNpemUgPiAwKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuICAgICAgfVxuICAgIH0sICgpID0+IFN0cmluZyh2YWx1ZSkpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGF0ZVRpbWUsXG4gICAgbnVtYmVyLFxuICAgIHJlbGF0aXZlVGltZSxcbiAgICBsaXN0XG4gIH07XG59XG5cbmV4cG9ydHMuY3JlYXRlQmFzZVRyYW5zbGF0b3IgPSBjcmVhdGVCYXNlVHJhbnNsYXRvcjtcbmV4cG9ydHMuY3JlYXRlRm9ybWF0dGVyID0gY3JlYXRlRm9ybWF0dGVyO1xuZXhwb3J0cy5yZXNvbHZlTmFtZXNwYWNlID0gcmVzb2x2ZU5hbWVzcGFjZTtcbiJdLCJuYW1lcyI6WyJJbnRsTWVzc2FnZUZvcm1hdCIsInJlcXVpcmUiLCJSZWFjdCIsImluaXRpYWxpemVDb25maWciLCJfaW50ZXJvcERlZmF1bHQiLCJlIiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJJbnRsTWVzc2FnZUZvcm1hdF9fZGVmYXVsdCIsInNldFRpbWVab25lSW5Gb3JtYXRzIiwiZm9ybWF0cyIsInRpbWVab25lIiwiT2JqZWN0Iiwia2V5cyIsInJlZHVjZSIsImFjYyIsImtleSIsImNvbnZlcnRGb3JtYXRzVG9JbnRsTWVzc2FnZUZvcm1hdCIsImZvcm1hdHNXaXRoVGltZVpvbmUiLCJkYXRlVGltZSIsIm1mRGF0ZURlZmF1bHRzIiwiZGF0ZSIsImRlZmF1bHREYXRlRm9ybWF0cyIsIm1mVGltZURlZmF1bHRzIiwidGltZSIsImRlZmF1bHRUaW1lRm9ybWF0cyIsInJlc29sdmVQYXRoIiwibG9jYWxlIiwibWVzc2FnZXMiLCJuYW1lc3BhY2UiLCJmdWxsS2V5Iiwiam9pblBhdGgiLCJFcnJvciIsImNvbmNhdCIsIm1lc3NhZ2UiLCJzcGxpdCIsImZvckVhY2giLCJwYXJ0IiwibmV4dCIsInByZXBhcmVUcmFuc2xhdGlvblZhbHVlcyIsInZhbHVlcyIsImxlbmd0aCIsInVuZGVmaW5lZCIsInRyYW5zZm9ybWVkVmFsdWVzIiwiaW5kZXgiLCJ2YWx1ZSIsInRyYW5zZm9ybWVkIiwiY2h1bmtzIiwicmVzdWx0IiwiaXNWYWxpZEVsZW1lbnQiLCJjbG9uZUVsZW1lbnQiLCJnZXRNZXNzYWdlc09yRXJyb3IiLCJvbkVycm9yIiwiYXJndW1lbnRzIiwiZGVmYXVsdE9uRXJyb3IiLCJyZXRyaWV2ZWRNZXNzYWdlcyIsImVycm9yIiwiaW50bEVycm9yIiwiSW50bEVycm9yIiwiSW50bEVycm9yQ29kZSIsIk1JU1NJTkdfTUVTU0FHRSIsImdldFBsYWluTWVzc2FnZSIsImNhbmRpZGF0ZSIsInVuZXNjYXBlZE1lc3NhZ2UiLCJyZXBsYWNlIiwiaGFzUGxhY2Vob2xkZXJzIiwidGVzdCIsImNyZWF0ZUJhc2VUcmFuc2xhdG9yIiwiY29uZmlnIiwibWVzc2FnZXNPckVycm9yIiwiY3JlYXRlQmFzZVRyYW5zbGF0b3JJbXBsIiwiX3JlZiIsImRlZmF1bHRUcmFuc2xhdGlvblZhbHVlcyIsImdsb2JhbEZvcm1hdHMiLCJnZXRNZXNzYWdlRmFsbGJhY2siLCJkZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrIiwibWVzc2FnZUZvcm1hdENhY2hlIiwiZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkiLCJjb2RlIiwidHJhbnNsYXRlQmFzZUZuIiwiY2FjaGVLZXkiLCJTdHJpbmciLCJtZXNzYWdlRm9ybWF0IiwiaGFzIiwiZ2V0IiwiZXJyb3JNZXNzYWdlIiwiQXJyYXkiLCJpc0FycmF5IiwiSU5WQUxJRF9NRVNTQUdFIiwiSU5TVUZGSUNJRU5UX1BBVEgiLCJwbGFpbk1lc3NhZ2UiLCJmb3JtYXR0ZXJzIiwiZ2V0TnVtYmVyRm9ybWF0IiwibG9jYWxlcyIsIm9wdGlvbnMiLCJJbnRsIiwiTnVtYmVyRm9ybWF0IiwiZ2V0RGF0ZVRpbWVGb3JtYXQiLCJEYXRlVGltZUZvcm1hdCIsImdldFBsdXJhbFJ1bGVzIiwiUGx1cmFsUnVsZXMiLCJ0aHJvd25FcnJvciIsIm9yaWdpbmFsTWVzc2FnZSIsInNldCIsImZvcm1hdHRlZE1lc3NhZ2UiLCJmb3JtYXQiLCJGT1JNQVRUSU5HX0VSUk9SIiwidHJhbnNsYXRlRm4iLCJyaWNoIiwibWFya3VwIiwicmF3IiwicmVzb2x2ZU5hbWVzcGFjZSIsIm5hbWVzcGFjZVByZWZpeCIsInNsaWNlIiwiU0VDT05EIiwiTUlOVVRFIiwiSE9VUiIsIkRBWSIsIldFRUsiLCJNT05USCIsIlFVQVJURVIiLCJZRUFSIiwiVU5JVF9TRUNPTkRTIiwic2Vjb25kIiwic2Vjb25kcyIsIm1pbnV0ZSIsIm1pbnV0ZXMiLCJob3VyIiwiaG91cnMiLCJkYXkiLCJkYXlzIiwid2VlayIsIndlZWtzIiwibW9udGgiLCJtb250aHMiLCJxdWFydGVyIiwicXVhcnRlcnMiLCJ5ZWFyIiwieWVhcnMiLCJyZXNvbHZlUmVsYXRpdmVUaW1lVW5pdCIsImFic1ZhbHVlIiwiTWF0aCIsImFicyIsImNhbGN1bGF0ZVJlbGF0aXZlVGltZVZhbHVlIiwidW5pdCIsInJvdW5kIiwiY3JlYXRlRm9ybWF0dGVyIiwibm93IiwiZ2xvYmFsTm93IiwiZ2xvYmFsVGltZVpvbmUiLCJyZXNvbHZlRm9ybWF0T3JPcHRpb25zIiwidHlwZUZvcm1hdHMiLCJmb3JtYXRPck9wdGlvbnMiLCJmb3JtYXROYW1lIiwiTUlTU0lOR19GT1JNQVQiLCJnZXRGb3JtYXR0ZWRWYWx1ZSIsImZvcm1hdHRlciIsImdldEZhbGxiYWNrIiwiX29wdGlvbnMiLCJFTlZJUk9OTUVOVF9GQUxMQkFDSyIsIm51bWJlciIsImdldEdsb2JhbE5vdyIsIkRhdGUiLCJleHRyYWN0Tm93RGF0ZSIsIm5vd09yT3B0aW9ucyIsInJlbGF0aXZlVGltZSIsImRhdGVEYXRlIiwibm93RGF0ZSIsImdldFRpbWUiLCJSZWxhdGl2ZVRpbWVGb3JtYXQiLCJudW1lcmljIiwibGlzdCIsInNlcmlhbGl6ZWRWYWx1ZSIsInJpY2hWYWx1ZXMiLCJNYXAiLCJpdGVtIiwic2VyaWFsaXplZEl0ZW0iLCJwdXNoIiwiTGlzdEZvcm1hdCIsImZvcm1hdFRvUGFydHMiLCJtYXAiLCJ0eXBlIiwic2l6ZSIsImpvaW4iLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/use-intl/dist/development/createFormatter-4ce6f6c8.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/use-intl/dist/development/initializeConfig-c503e215.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/use-intl/dist/development/initializeConfig-c503e215.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPrimitive(input, hint) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (typeof res !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n}\nlet IntlErrorCode = /*#__PURE__*/ function(IntlErrorCode) {\n    IntlErrorCode[\"MISSING_MESSAGE\"] = \"MISSING_MESSAGE\";\n    IntlErrorCode[\"MISSING_FORMAT\"] = \"MISSING_FORMAT\";\n    IntlErrorCode[\"ENVIRONMENT_FALLBACK\"] = \"ENVIRONMENT_FALLBACK\";\n    IntlErrorCode[\"INSUFFICIENT_PATH\"] = \"INSUFFICIENT_PATH\";\n    IntlErrorCode[\"INVALID_MESSAGE\"] = \"INVALID_MESSAGE\";\n    IntlErrorCode[\"INVALID_KEY\"] = \"INVALID_KEY\";\n    IntlErrorCode[\"FORMATTING_ERROR\"] = \"FORMATTING_ERROR\";\n    return IntlErrorCode;\n}({});\nclass IntlError extends Error {\n    constructor(code, originalMessage){\n        let message = code;\n        if (originalMessage) {\n            message += \": \" + originalMessage;\n        }\n        super(message);\n        _defineProperty(this, \"code\", void 0);\n        _defineProperty(this, \"originalMessage\", void 0);\n        this.code = code;\n        if (originalMessage) {\n            this.originalMessage = originalMessage;\n        }\n    }\n}\nfunction joinPath() {\n    for(var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++){\n        parts[_key] = arguments[_key];\n    }\n    return parts.filter(Boolean).join(\".\");\n}\n/**\n * Contains defaults that are used for all entry points into the core.\n * See also `InitializedIntlConfiguration`.\n */ function defaultGetMessageFallback(props) {\n    return joinPath(props.namespace, props.key);\n}\nfunction defaultOnError(error) {\n    console.error(error);\n}\nfunction validateMessagesSegment(messages, invalidKeyLabels, parentPath) {\n    Object.entries(messages).forEach((_ref)=>{\n        let [key, messageOrMessages] = _ref;\n        if (key.includes(\".\")) {\n            let keyLabel = key;\n            if (parentPath) keyLabel += \" (at \".concat(parentPath, \")\");\n            invalidKeyLabels.push(keyLabel);\n        }\n        if (messageOrMessages != null && typeof messageOrMessages === \"object\") {\n            validateMessagesSegment(messageOrMessages, invalidKeyLabels, joinPath(parentPath, key));\n        }\n    });\n}\nfunction validateMessages(messages, onError) {\n    const invalidKeyLabels = [];\n    validateMessagesSegment(messages, invalidKeyLabels);\n    if (invalidKeyLabels.length > 0) {\n        onError(new IntlError(IntlErrorCode.INVALID_KEY, 'Namespace keys can not contain the character \".\" as this is used to express nesting. Please remove it or replace it with another character.\\n\\nInvalid '.concat(invalidKeyLabels.length === 1 ? \"key\" : \"keys\", \": \").concat(invalidKeyLabels.join(\", \"), '\\n\\nIf you\\'re migrating from a flat structure, you can convert your messages as follows:\\n\\nimport {set} from \"lodash\";\\n\\nconst input = {\\n  \"one.one\": \"1.1\",\\n  \"one.two\": \"1.2\",\\n  \"two.one.one\": \"2.1.1\"\\n};\\n\\nconst output = Object.entries(input).reduce(\\n  (acc, [key, value]) => set(acc, key, value),\\n  {}\\n);\\n\\n// Output:\\n//\\n// {\\n//   \"one\": {\\n//     \"one\": \"1.1\",\\n//     \"two\": \"1.2\"\\n//   },\\n//   \"two\": {\\n//     \"one\": {\\n//       \"one\": \"2.1.1\"\\n//     }\\n//   }\\n// }\\n')));\n    }\n}\n/**\n * Enhances the incoming props with defaults.\n */ function initializeConfig(_ref) {\n    let { getMessageFallback, messages, onError, ...rest } = _ref;\n    const finalOnError = onError || defaultOnError;\n    const finalGetMessageFallback = getMessageFallback || defaultGetMessageFallback;\n    {\n        if (messages) {\n            validateMessages(messages, finalOnError);\n        }\n    }\n    return {\n        ...rest,\n        messages,\n        onError: finalOnError,\n        getMessageFallback: finalGetMessageFallback\n    };\n}\nexports.IntlError = IntlError;\nexports.IntlErrorCode = IntlErrorCode;\nexports.defaultGetMessageFallback = defaultGetMessageFallback;\nexports.defaultOnError = defaultOnError;\nexports.initializeConfig = initializeConfig;\nexports.joinPath = joinPath;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9pbml0aWFsaXplQ29uZmlnLWM1MDNlMjE1LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsU0FBU0EsZ0JBQWdCQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsS0FBSztJQUN0Q0QsTUFBTUUsZUFBZUY7SUFDckIsSUFBSUEsT0FBT0QsS0FBSztRQUNkSSxPQUFPQyxjQUFjLENBQUNMLEtBQUtDLEtBQUs7WUFDOUJDLE9BQU9BO1lBQ1BJLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1FBQ1o7SUFDRixPQUFPO1FBQ0xSLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHQztJQUNiO0lBQ0EsT0FBT0Y7QUFDVDtBQUNBLFNBQVNTLGFBQWFDLEtBQUssRUFBRUMsSUFBSTtJQUMvQixJQUFJLE9BQU9ELFVBQVUsWUFBWUEsVUFBVSxNQUFNLE9BQU9BO0lBQ3hELElBQUlFLE9BQU9GLEtBQUssQ0FBQ0csT0FBT0MsV0FBVyxDQUFDO0lBQ3BDLElBQUlGLFNBQVNHLFdBQVc7UUFDdEIsSUFBSUMsTUFBTUosS0FBS0ssSUFBSSxDQUFDUCxPQUFPQyxRQUFRO1FBQ25DLElBQUksT0FBT0ssUUFBUSxVQUFVLE9BQU9BO1FBQ3BDLE1BQU0sSUFBSUUsVUFBVTtJQUN0QjtJQUNBLE9BQU8sQ0FBQ1AsU0FBUyxXQUFXUSxTQUFTQyxNQUFLLEVBQUdWO0FBQy9DO0FBQ0EsU0FBU1AsZUFBZWtCLEdBQUc7SUFDekIsSUFBSXBCLE1BQU1RLGFBQWFZLEtBQUs7SUFDNUIsT0FBTyxPQUFPcEIsUUFBUSxXQUFXQSxNQUFNa0IsT0FBT2xCO0FBQ2hEO0FBRUEsSUFBSXFCLGdCQUFnQixXQUFXLEdBQUUsU0FBVUEsYUFBYTtJQUN0REEsYUFBYSxDQUFDLGtCQUFrQixHQUFHO0lBQ25DQSxhQUFhLENBQUMsaUJBQWlCLEdBQUc7SUFDbENBLGFBQWEsQ0FBQyx1QkFBdUIsR0FBRztJQUN4Q0EsYUFBYSxDQUFDLG9CQUFv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dXJjZXMiOlsid2VicGFjazovL3B3YS1zYWFzLy4vbm9kZV9tb2R1bGVzL3VzZS1pbnRsL2Rpc3QvZGV2ZWxvcG1lbnQvaW5pdGlhbGl6ZUNvbmZpZy1jNTAzZTIxNS5qcz9hYzQ4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpO1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDtcbiAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKHR5cGVvZiByZXMgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpO1xufVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7XG4gIHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTtcbn1cblxubGV0IEludGxFcnJvckNvZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKEludGxFcnJvckNvZGUpIHtcbiAgSW50bEVycm9yQ29kZVtcIk1JU1NJTkdfTUVTU0FHRVwiXSA9IFwiTUlTU0lOR19NRVNTQUdFXCI7XG4gIEludGxFcnJvckNvZGVbXCJNSVNTSU5HX0ZPUk1BVFwiXSA9IFwiTUlTU0lOR19GT1JNQVRcIjtcbiAgSW50bEVycm9yQ29kZVtcIkVOVklST05NRU5UX0ZBTExCQUNLXCJdID0gXCJFTlZJUk9OTUVOVF9GQUxMQkFDS1wiO1xuICBJbnRsRXJyb3JDb2RlW1wiSU5TVUZGSUNJRU5UX1BBVEhcIl0gPSBcIklOU1VGRklDSUVOVF9QQVRIXCI7XG4gIEludGxFcnJvckNvZGVbXCJJTlZBTElEX01FU1NBR0VcIl0gPSBcIklOVkFMSURfTUVTU0FHRVwiO1xuICBJbnRsRXJyb3JDb2RlW1wiSU5WQUxJRF9LRVlcIl0gPSBcIklOVkFMSURfS0VZXCI7XG4gIEludGxFcnJvckNvZGVbXCJGT1JNQVRUSU5HX0VSUk9SXCJdID0gXCJGT1JNQVRUSU5HX0VSUk9SXCI7XG4gIHJldHVybiBJbnRsRXJyb3JDb2RlO1xufSh7fSk7XG5jbGFzcyBJbnRsRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNvZGUsIG9yaWdpbmFsTWVzc2FnZSkge1xuICAgIGxldCBtZXNzYWdlID0gY29kZTtcbiAgICBpZiAob3JpZ2luYWxNZXNzYWdlKSB7XG4gICAgICBtZXNzYWdlICs9ICc6ICcgKyBvcmlnaW5hbE1lc3NhZ2U7XG4gICAgfVxuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvcmlnaW5hbE1lc3NhZ2VcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIGlmIChvcmlnaW5hbE1lc3NhZ2UpIHtcbiAgICAgIHRoaXMub3JpZ2luYWxNZXNzYWdlID0gb3JpZ2luYWxNZXNzYWdlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBqb2luUGF0aCgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBhcnRzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHBhcnRzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIHJldHVybiBwYXJ0cy5maWx0ZXIoQm9vbGVhbikuam9pbignLicpO1xufVxuXG4vKipcbiAqIENvbnRhaW5zIGRlZmF1bHRzIHRoYXQgYXJlIHVzZWQgZm9yIGFsbCBlbnRyeSBwb2ludHMgaW50byB0aGUgY29yZS5cbiAqIFNlZSBhbHNvIGBJbml0aWFsaXplZEludGxDb25maWd1cmF0aW9uYC5cbiAqL1xuXG5mdW5jdGlvbiBkZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrKHByb3BzKSB7XG4gIHJldHVybiBqb2luUGF0aChwcm9wcy5uYW1lc3BhY2UsIHByb3BzLmtleSk7XG59XG5mdW5jdGlvbiBkZWZhdWx0T25FcnJvcihlcnJvcikge1xuICBjb25zb2xlLmVycm9yKGVycm9yKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVNZXNzYWdlc1NlZ21lbnQobWVzc2FnZXMsIGludmFsaWRLZXlMYWJlbHMsIHBhcmVudFBhdGgpIHtcbiAgT2JqZWN0LmVudHJpZXMobWVzc2FnZXMpLmZvckVhY2goX3JlZiA9PiB7XG4gICAgbGV0IFtrZXksIG1lc3NhZ2VPck1lc3NhZ2VzXSA9IF9yZWY7XG4gICAgaWYgKGtleS5pbmNsdWRlcygnLicpKSB7XG4gICAgICBsZXQga2V5TGFiZWwgPSBrZXk7XG4gICAgICBpZiAocGFyZW50UGF0aCkga2V5TGFiZWwgKz0gXCIgKGF0IFwiLmNvbmNhdChwYXJlbnRQYXRoLCBcIilcIik7XG4gICAgICBpbnZhbGlkS2V5TGFiZWxzLnB1c2goa2V5TGFiZWwpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZU9yTWVzc2FnZXMgIT0gbnVsbCAmJiB0eXBlb2YgbWVzc2FnZU9yTWVzc2FnZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YWxpZGF0ZU1lc3NhZ2VzU2VnbWVudChtZXNzYWdlT3JNZXNzYWdlcywgaW52YWxpZEtleUxhYmVscywgam9pblBhdGgocGFyZW50UGF0aCwga2V5KSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTWVzc2FnZXMobWVzc2FnZXMsIG9uRXJyb3IpIHtcbiAgY29uc3QgaW52YWxpZEtleUxhYmVscyA9IFtdO1xuICB2YWxpZGF0ZU1lc3NhZ2VzU2VnbWVudChtZXNzYWdlcywgaW52YWxpZEtleUxhYmVscyk7XG4gIGlmIChpbnZhbGlkS2V5TGFiZWxzLmxlbmd0aCA+IDApIHtcbiAgICBvbkVycm9yKG5ldyBJbnRsRXJyb3IoSW50bEVycm9yQ29kZS5JTlZBTElEX0tFWSwgXCJOYW1lc3BhY2Uga2V5cyBjYW4gbm90IGNvbnRhaW4gdGhlIGNoYXJhY3RlciBcXFwiLlxcXCIgYXMgdGhpcyBpcyB1c2VkIHRvIGV4cHJlc3MgbmVzdGluZy4gUGxlYXNlIHJlbW92ZSBpdCBvciByZXBsYWNlIGl0IHdpdGggYW5vdGhlciBjaGFyYWN0ZXIuXFxuXFxuSW52YWxpZCBcIi5jb25jYXQoaW52YWxpZEtleUxhYmVscy5sZW5ndGggPT09IDEgPyAna2V5JyA6ICdrZXlzJywgXCI6IFwiKS5jb25jYXQoaW52YWxpZEtleUxhYmVscy5qb2luKCcsICcpLCBcIlxcblxcbklmIHlvdSdyZSBtaWdyYXRpbmcgZnJvbSBhIGZsYXQgc3RydWN0dXJlLCB5b3UgY2FuIGNvbnZlcnQgeW91ciBtZXNzYWdlcyBhcyBmb2xsb3dzOlxcblxcbmltcG9ydCB7c2V0fSBmcm9tIFxcXCJsb2Rhc2hcXFwiO1xcblxcbmNvbnN0IGlucHV0ID0ge1xcbiAgXFxcIm9uZS5vbmVcXFwiOiBcXFwiMS4xXFxcIixcXG4gIFxcXCJvbmUudHdvXFxcIjogXFxcIjEuMlxcXCIsXFxuICBcXFwidHdvLm9uZS5vbmVcXFwiOiBcXFwiMi4xLjFcXFwiXFxufTtcXG5cXG5jb25zdCBvdXRwdXQgPSBPYmplY3QuZW50cmllcyhpbnB1dCkucmVkdWNlKFxcbiAgKGFjYywgW2tleSwgdmFsdWVdKSA9PiBzZXQoYWNjLCBrZXksIHZhbHVlKSxcXG4gIHt9XFxuKTtcXG5cXG4vLyBPdXRwdXQ6XFxuLy9cXG4vLyB7XFxuLy8gICBcXFwib25lXFxcIjoge1xcbi8vICAgICBcXFwib25lXFxcIjogXFxcIjEuMVxcXCIsXFxuLy8gICAgIFxcXCJ0d29cXFwiOiBcXFwiMS4yXFxcIlxcbi8vICAgfSxcXG4vLyAgIFxcXCJ0d29cXFwiOiB7XFxuLy8gICAgIFxcXCJvbmVcXFwiOiB7XFxuLy8gICAgICAgXFxcIm9uZVxcXCI6IFxcXCIyLjEuMVxcXCJcXG4vLyAgICAgfVxcbi8vICAgfVxcbi8vIH1cXG5cIikgKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbmhhbmNlcyB0aGUgaW5jb21pbmcgcHJvcHMgd2l0aCBkZWZhdWx0cy5cbiAqL1xuZnVuY3Rpb24gaW5pdGlhbGl6ZUNvbmZpZyhfcmVmKSB7XG4gIGxldCB7XG4gICAgZ2V0TWVzc2FnZUZhbGxiYWNrLFxuICAgIG1lc3NhZ2VzLFxuICAgIG9uRXJyb3IsXG4gICAgLi4ucmVzdFxuICB9ID0gX3JlZjtcbiAgY29uc3QgZmluYWxPbkVycm9yID0gb25FcnJvciB8fCBkZWZhdWx0T25FcnJvcjtcbiAgY29uc3QgZmluYWxHZXRNZXNzYWdlRmFsbGJhY2sgPSBnZXRNZXNzYWdlRmFsbGJhY2sgfHwgZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjaztcbiAge1xuICAgIGlmIChtZXNzYWdlcykge1xuICAgICAgdmFsaWRhdGVNZXNzYWdlcyhtZXNzYWdlcywgZmluYWxPbkVycm9yKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5yZXN0LFxuICAgIG1lc3NhZ2VzLFxuICAgIG9uRXJyb3I6IGZpbmFsT25FcnJvcixcbiAgICBnZXRNZXNzYWdlRmFsbGJhY2s6IGZpbmFsR2V0TWVzc2FnZUZhbGxiYWNrXG4gIH07XG59XG5cbmV4cG9ydHMuSW50bEVycm9yID0gSW50bEVycm9yO1xuZXhwb3J0cy5JbnRsRXJyb3JDb2RlID0gSW50bEVycm9yQ29kZTtcbmV4cG9ydHMuZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjayA9IGRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2s7XG5leHBvcnRzLmRlZmF1bHRPbkVycm9yID0gZGVmYXVsdE9uRXJyb3I7XG5leHBvcnRzLmluaXRpYWxpemVDb25maWcgPSBpbml0aWFsaXplQ29uZmlnO1xuZXhwb3J0cy5qb2luUGF0aCA9IGpvaW5QYXRoO1xuIl0sIm5hbWVzIjpbIl9kZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsInZhbHVlIiwiX3RvUHJvcGVydHlLZXkiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1ByaW1pdGl2ZSIsImlucHV0IiwiaGludCIsInByaW0iLCJTeW1ib2wiLCJ0b1ByaW1pdGl2ZSIsInVuZGVmaW5lZCIsInJlcyIsImNhbGwiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiLCJhcmciLCJJbnRsRXJyb3JDb2RlIiwiSW50bEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsImNvZGUiLCJvcmlnaW5hbE1lc3NhZ2UiLCJtZXNzYWdlIiwiam9pblBhdGgiLCJfbGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwicGFydHMiLCJBcnJheSIsIl9rZXkiLCJmaWx0ZXIiLCJCb29sZWFuIiwiam9pbiIsImRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2siLCJwcm9wcyIsIm5hbWVzcGFjZSIsImRlZmF1bHRPbkVycm9yIiwiZXJyb3IiLCJjb25zb2xlIiwidmFsaWRhdGVNZXNzYWdlc1NlZ21lbnQiLCJtZXNzYWdlcyIsImludmFsaWRLZXlMYWJlbHMiLCJwYXJlbnRQYXRoIiwiZW50cmllcyIsImZvckVhY2giLCJfcmVmIiwibWVzc2FnZU9yTWVzc2FnZXMiLCJpbmNsdWRlcyIsImtleUxhYmVsIiwiY29uY2F0IiwicHVzaCIsInZhbGlkYXRlTWVzc2FnZXMiLCJvbkVycm9yIiwiSU5WQUxJRF9LRVkiLCJpbml0aWFsaXplQ29uZmlnIiwiZ2V0TWVzc2FnZUZhbGxiYWNrIiwicmVzdCIsImZpbmFsT25FcnJvciIsImZpbmFsR2V0TWVzc2FnZUZhbGxiYWNrIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/use-intl/dist/development/initializeConfig-c503e215.js\n");

/***/ })

};
;